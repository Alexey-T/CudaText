== Comments ==

You can add/remove code comments, via "Comments" plugin. Plugin is preinstalled in CudaText. It gives about 6 commands in menu "Plugins / Comments". Plugin supports only adding/removing of comments, not syntax highlighting for them (highlighting is lexer's work).

* '''Line comments''': from some position to the nearest end-of-line. E.g. in C lexer: "//text here", in Python lexer: "# text here".
* '''Comments for range''' ('''Stream comments'''): from some text position to some bigger text position, often in the different line. E.g. in C lexer: "/* text here */".
* '''Comments for full lines''': from newline to another newline, ie comment for several whole lines. Rarely used, e.g. used in PowerShell.

For example, Python lexer supports only line comment, and don't support stream comments. PowerShell lexer supports comments for full lines, while don't support comments for any range.

Comment chars are editable in SynWrite editor, in dialog "Lexer properties" (after you install the same lexer to SynWrite). In dialog tab "Commenting" you'll see input fields.

Command "Toggle stream comment" in plugin adds/removes comments of last 2 types: for range, for full lines (plugin chooses needed kind).

Comment chars are saved:

* Line comments: in lexer file data/lexlib/nnn.lcf.
* Range comments: in files data/lexlib/nnn.cuda-lexmap.

== Macros ==

Macro is a sequence of CudaText actions, which can be saved to a file and invoked later by some command.
To use macros, you must install plugin "Macros" from Addon Manager. It adds "Macros" menu to CudaText main menu bar. This menu gives items:

* Macros...
* Start record
* Stop record
* Cancel record
* Export...
* Import...
* (items for saved macros)

To record a macro:

* call menu item "Macros / Start record", or use dialog "Macros / Macros..." which gives "Start record" button too
* pefrorm some action(s) in CudaText:
** built-in commands, plugin commands (invoked by hotkey, by menu, by Command Palette)
** some mouse actions (clicks/selections, they save/playback relative to caret position)
** calling of Find/Replace dialog, "Go to" dialog
** actions in Find/Replace dialog
* call menu item "Macros / Stop record" to save your macro, plugin will ask for macro name

Macro saves action(s) performed inside its original editor tab (not other tabs). And it doesn't save actions inside plugin dialogs (e.g. FindInFiles).

To playback macro:

* call menu item "Macros / (macro name)", the end of this menu lists all available/saved macros
* or call dialog "Macros / Macros..." which allows to run available macros: it can be simple running, running N times, or running in loop ([x] While text changes, [x] Until caret on last line)

== Project Manager ==

This plugin is preinstalled in CudaText. It shows panel "Project" in the sidebar (to show this panel, call plugin by any command, or set plugin's option "Load on program start" and restart, CudaText sidebar will have Project button). On the project panel, on its tree-view, you can add several "root nodes", each node must be existing file or folder. For folder nodes, plugin auto shows all nested folders. You cannot add nodes on other levels (like SynWrite editor does).

Plugin has context menu on its panel, with items:

* Project file
** New project
** Open project
** Recent projects
** Save project as...
** Go to file... - this shows menu with all project files, and then tree-view selection jumps on selected file
** Project properties... - this shows dialog with current project's options
** Config... - this shows dialog with global Project Manager options
* Root nodes - commands for nodes on the project's root level
** Add folder...
** Add file...
** Clear project
** Remove node
* Selected file - it's shown only for files
* Selected directory - it's shown only for folders
* Refresh - it re-reads state of files/folders from disk

Any project can have "main file", you can choose it in the context menu: "Selected file / Set as main file". Main file's path is used by plugin External Tools, when some tool is configured with macro {ProjMainFile}. This allows tools to run compilation of the main file.

=== Project Manager options dialog ===

* "Ignore files": ";"-separated shell wildcards, which are [https://docs.python.org/3/library/fnmatch.html documented here]. If file name (without path) matches any of these wildcards, it will not be listed in the treeview.
* "Ignore folders": ";"-separated shell wildcards. If folder name matches any of these wildcards, it will not be listed in the treeview.
* "Ignore all hidden files/folders": Additionally don't list all hidden items. On Unix, hidden mean "beginning with dot". On Windows, hidden means having file-system "hidden" attribute.
* "Open file after "Go to file" command": If turned on, command "Project Manager: Go to file" will not only jump to chosen file in the treeview, but also open that file in editor.
* "Use "preview tab" on item clicking": If option is on, single click on treeview file item, will open file in "preview tab". Preview tab is single such tab, it's shared by all files, it has italic+underlined tab title. If option is off, clicking file item will open normal tab, separate normal tabs per each file.
* "Open files by double-click": If turned on, only double-click in the treeview will open file for editing, but not the single click.
* "On opening file in Git/SVN repo...": On opening any file, Project Manager will check if this file is in the Git/SVN repository (by presence of folder ".git" or ".svn" near the file, or in upper level folders). If yes, Project Manager will create the project from that repository and open it. This gives some slowdown of course.

And options for icons:

* "File type icons": Set of file/folder icons for treeview. You can install additional themes from Addons Manager, see category "filetypeicons" there. Example of such theme: "VSCode Material 24x24". This option shows  themes, which are present in the folder "data/filetypeicons".
* "Toolbar icons": Set of icons for Project Manager toolbar buttons. You can install additional themes from Addon Manager, see the category "projtoolbaricons" there. This option shows themes, which are present in the folder "data/projtoolbaricons".

=== Preview tab ===

To see the "preview tab", call "File / Open folder" and choose a folder with some files. Folder will be opened in the side panel "Project". Make single click on a file in this project, it will open in the "preview tab". Single "preview tab" is shared by all clicked (in the project) files. It has italic font style of the caption (font style is customizable). When you begin to edit file in the "preview tab", tab becomes "normal" and looses its special status.

"Preview tab" is always '''created in the first tab-group''', even if the focused editor is located in different tab-group.
It was made on purpose, to avoid the situation when "preview tab" jumps from one tab-group to another.

Again, if you click different items in the Project Manager, and files are opened '''in the first tab-group''', it's not a bug.
If you need to open clicked files in different tab-groups, you can do it - by unchecking the option "Use preview tab on item clicking" in the Project Manager options.

"Preview tab" can be dragged to another tab-group, it should work there too.

=== Switch between projects ===

1) To switch to different project, Plugin Manager gives the context menu: "Project File / Recent projects / name.cuda-proj".

2) Another way is using the plugin "Favorites". It gives the dialog (can be called by a hotkey), with 2 tabs: "Files" and "Projects", so you can choose one of your favorite projects from a listbox.

3) There is also a way to quickly switch between projects:

* Install plugins: "Config Toolbar", "External Tools" and "Session Manager". Restart CudaText.
* Set CudaText option "ui_one_instance": true.
* In "External Tools" make a tool which starts CudaText (yes, from within CudaText) with parameter: full path of a project. The command line can look like: "c:\Apps\cudatext.exe "c:\Apps\some_project.cuda-proj"". You can add here additional parameter: full path of a session file, *.cuda-session / *.json. So this external tool will open given project (and maybe a session too). It will open it inside the same CudaText instance (because "ui_one_instance":true).
* Add more such tools in the "External Tools", for different projects (and maybe sessions).

[[File:cudatext-tools-and-projects.png]]

* In the plugin "Config Toolbar", add the toolbar drop-down menu, with menu-items referring to different tools. Or add the individual menu-items for separate tools.

[[File:cudatext-tools-and-projects-config.png]]

4) There is a method for CudaText 1.145.1 or newer.

* Install plugin "Config Toolbar" (only 1 plugin here, comparing to the previous method).
* CudaText option "ui_one_instance" can be any.
* In the plugin "Config Toolbar", add the toolbar button which will switch the project and/or session. The properties of this button are tricky. In the "Command" property of the button, you must enter "exec=path_of_project_file path_of_session file". You cannot type this directly to the dialog field, but you should press the "Enter command line..." button in the dialog and enter the command line contents (full path of .cuda-proj file and/or full path of .cuda-session file). "Config Toolbar" will store your command line with the "exec=" prefix.
* CudaText will use the new command-line which you entered after "exec=".

== Snippets ==

To use snippets you need:

* plugin "Snippets" (install from Addon Manager)
* snippet package for needed lexer (install from Addon Manager)

Each snippet has a name (shown in the dialog when Snippets plugin is called) and short id (letters, digits, '_', dot). You can type id in editor and press Tab key: snippet for this id will be inserted into text. You can insert snippets also by choosing in dialog: call menu item "Plugins / Snippets".

Only those snippets are enabled, which are suitable for the current lexer. For example, a snippet may be for lexers "C,C++,Objective C" - it is enabled only when these lexers are active. If a snippet has no lexer property, it is always enabled.

Dialog of Snippets plugin:

[[File:cudatext_snippets_menu.png]]

Texts of snippets usually have tab-stop(s), e.g. ${1:some_text}. Plugin Snippets finds tab-stops and places "markers" for them. After markers are placed, Tab-key works special in editor, it jumps to next marker. See detailed information in the [[CudaText#Markers]].

=== Snippets from VSCode ===
Since recent versions, Snippets plugin supports snippets from VSCode editor. It gives menu items in "Plugins / Snippets":

* "Install VSCode snippets..." - this suggests to install packages with snippets (packages usually contain more functionality, and CudaText plugin will install only snippets).

[[File:cudatext-snippets-add-vscode.png]]

* "Remove VSCode snippets"
* "Visit homepage of VSCode snippets..."
* "Convert snippets package from old format" - this takes snippets in old .cuda-snippet format (if you have some old ones) and converts them to VSCode JSON format.

Plugin also gives the fully featured snippet editor dialog, in menu item "Add/edit snippets...".

[[File:cudatext-snippets-editor.png]]

Currently most of VSCode/TextMate "macros" are supported in snippets body, but not all. Refer to readme file of the plugin.

=== Snippets for HTML tags ===

CudaText has preinstalled 120+ snippets for HTML tags. (You still need to install Snippets plugin.) They are enabled with HTML lexer. Just type tag name without a bracket, press Tab, and snippet is inserted. E.g. "a"<Tab> will insert:

  <a href="http" title="Title" target="_blank"></a>

These snippets have markers, so Tab key jumps to the next marker. Last marker is usually placed after the entire tag, ie after ">" bracket.

===Format of snippet files===

====Snippets tab-stops====

Specify tab-stops in the snippet text like this:

* ${NN}
* ${NN:default text}

This places markers (AKA tab-stops) in the editor, marker index NN should be from 0 to 40.
After snippet insertion, tab-key goes to next marker(s) and deletes it.

* Markers can be listed in any order (e.g. marker 4 can be between 1 and 2).
* Tab-key first goes to marker 1, 2, 3... and marker 0 is always the last.
* Markers with the same indexes will place multi-carets.
* Nested markers (with default text) are allowed, but only with one nesting level, e.g. ${2:text is {$3:here}}.
* Marker with default text ${NN:...} can specify multi-line default text (character "}" is on another line of snippet).

====Snippets macros====
Special macros are handled by Snippets plugin in snippet text:

* ${sel} - Text selected before snippet insertion (if snippet called with Tab key, it's empty string)
* ${cp} - Current clipboard contents

* ${cmt_start} - Current lexer's "block comment" start symbols (or empty string)
* ${cmt_end} - Current lexer's "block comment" end symbols (or empty string)
* ${cmt_line} - Current lexer's "line comment" symbols (or empty string)

* ${fname} - File name only, without path
* ${fpath} - Full file name, with path
* ${fdir} - Directory of file
* ${fext} - Extension of file
* ${psep} - OS path separator: backslash on Windows, slash on Unix

* ${date:nnnn} - Current date/time formatted by string "nnnn"; see [http://strftime.org/ Python docs]
* ${env:nnnn} - Value of OS environment variable "nnnn"

The following macros from Sublime Text editor are supported. They can be written as $NAME or as ${NAME}.

* $TM_SELECTED_TEXT - The currently selected text or the empty string
* $TM_CURRENT_LINE - The contents of the current line
* $TM_CURRENT_WORD - The contents of the word under cursor or the empty string
* $TM_LINE_INDEX - The zero-based line number
* $TM_LINE_NUMBER - The one-based line number
* $TM_FILEPATH - The full file path of the current document
* $TM_DIRECTORY - The directory of the current document
* $TM_FILENAME - The filename of the current document
* $TM_FILENAME_BASE - The filename of the current document without its extensions
* $CLIPBOARD - The contents of your clipboard
* $WORKSPACE_NAME - The name of the opened workspace or folder

* $BLOCK_COMMENT_START - Current lexer's "block comment" start symbols (or empty string)
* $BLOCK_COMMENT_END - Current lexer's "block comment" end symbols (or empty string)
* $LINE_COMMENT - Current lexer's "line comment" symbols (or empty string)

For inserting the current date and time:
* $CURRENT_YEAR - The current year
* $CURRENT_YEAR_SHORT - The current year's last two digits
* $CURRENT_MONTH - The month as two digits (e.g. '02')
* $CURRENT_MONTH_NAME - The full name of the month (e.g. 'July')
* $CURRENT_MONTH_NAME_SHORT - The short name of the month (e.g. 'Jul')
* $CURRENT_DATE - The day of the month
* $CURRENT_DAY_NAME - The name of day (e.g. 'Monday')
* $CURRENT_DAY_NAME_SHORT - The short name of the day (e.g. 'Mon')
* $CURRENT_HOUR - The current hour in 24-hour clock format
* $CURRENT_MINUTE - The current minute
* $CURRENT_SECOND - The current second
* $CURRENT_SECONDS_UNIX - The number of seconds since the Unix epoch

====Snippets file names====

Snippets are stored in separate files with extensions:

* .cuda-snippet or .synw-snippet: main format.
* .cuda-snips: compact format for collections of tiny snippets.

Encoding is UTF-8, no BOM. Files can be placed in any subfolder of "data/snippets" folder, file/folder names have no meaning, but it's recommended to name subfolders like AuthorName.SyntaxName, so users can easily find newly installed snippets.

====Format of .cuda-snippet====

First lines have format "key=value" (no spaces around "="), where "key" is one of strings:

* "name": snippet full name, shown in dialog.
* "id": snippet short alias for Tab-key (latin letters, digits, "_.$"), line is optional.
* "lex": lexers list, comma-separated, for which snippet is active, line is optional, empty means snippet always active.

Then follows the line "text=" without value, and all next lines - are snippet contents.

* Trailing blank lines are discarded.
* Use tab-chars in text indents, they are auto replaced to spaces if current editor configured so.

====Format of .cuda-snips====

File contains one or several lines, one snippet per line. Empty lines, lines starting with "#" or space, are ignored. Format of lines:

* id text
* /N=name text
* id /N=name text
* id /L=lexers text
* id /L=lexers /N=name text
* id /L="lexers" /N="name" text

Here "id" is short alias for Tab-key, "name" (if not set, it's the same as "id") is full name for dialog, "lexers" is comma-separated lexer list, "text" is snippet contents. Contents can have escaped special chars: "\n", "\r", "\t" (tab-char), "\\" (backslash).

== Snippet Panel ==

Plugin "Snippet Panel" is preinstalled in CudaText. It gives an alternative way to use short text fragments (only simple ones) in editor. It adds button to sidebar, and command "Plugins / Snippet Panel". When called, plugin shows panel in the sidebar, with a drop-down list of folders, which contain several "snippets". You can double-click snippets to insert them into text (multi-carets are supported).

Preinstalled folders:

* Arrows
* Currency symbols
* Greek alphabet (lower)
* Greek alphabet (upper)
* HTML - Arrows
* HTML - Color names
* HTML - Color names+values
* HTML - Letters
* HTML - Math symbols
* HTML - Special characters
* Math symbols
* Quote selection
* Special characters

Plugin looks for its folders in two places:

* Folder "clips" in the plugin folder.
* Folder CudaText/data/clips, which is absent by default, for custom user folders.

Each snippet folder can contain one or more .txt files, in UTF-8 (no BOM) or UTF-16 (with BOM) encoding. Files have snippet per line, in the form "name=value" or simply "name" (if value missed, it equals to name). Each snippet can be simple short string, or string with ${sel} macro to replace selected text. This allows to quote currently selected text by calling snippets from "Quote selection" folder.

== CudaLint ==

CudaLint plugin allows to check correctness of documents in many syntaxes.
It was initially ported from SublimeLinter 2.x plugin for Sublime Text. 
Each lexer must be supported with additionally installed linter, for example:

* JavaScript is supported with linter based on JSLint tool,
* HTML is supported with linter based on HTML Tidy tool,
* CSS is supported with linter based on CSSLint tool,
* etc

You will find all linters in the Addon Manager: "Plugins / Addon Manager / Install".
Linters are installable like other plugins but they don't add commands, they only add folders
"[CudaText]/py/cuda_lint_*", which are automatically used by CudaLint.
After you install a linter, see readme in its folder, maybe how-to-use info is written there.

=== Linters - usage ===

To run linting, use menu item "Plugins / CudaLint / Lint", or set hotkey to this command
(in CudaText Command Palette, press F9). You will see statusbar message, which tells how many errors
linter found. For each found error, you'll see yellow/red bookmark (you can use usual commands
for these bookmarks). Plugin also shows list of errors in the "Validate" panel
(to show Validate panel, click V icon on the CudaText sidebar).

Linting can also be run by events:

* after opening file
* on saving file
* after text is changed + pause passed

Events aren't used by default (to not slowdown usual work). To use events, you must enable them in config.
Call config by menu item in "Options / Settings-plugins".

=== Linters - Node.js ===

Some linters require Node.js, so for those linters, you must install Node first.
Those linters are sometimes shipped with Node modules preinstalled (in plugin folder)
and sometimes you need to install Node modules via NPM.
See linter's readme file for details.

* Windows: "node.exe" must be in PATH, command "node -v" must work in console.
* Linux: "nodejs" package must be installed, command "nodejs -v" must work in terminal.

=== Linters - authoring ===

To support more lexers, it's a good idea to port linter from SublimeLinter. To port a linter, most you need is:

* Fix "imports" to use "cuda_lint" module, instead of SublimeLinter modules. cuda_lint gives almost the same classes which SublimeLinter gives. Except Node.js linter class - it's not supported yet. Usual Linter and PythonLinter classes are supported.
* Change syntax name (for Sublime Text) to CudaText lexer name, names are often different. If no such lexer for CudaText exists yet, ask for it.
* Remove in linter usage of Sublime Text API to read settings (often used in linters). You can add usage of settings via CudaText API ini_read, or via json module.
* If linter was using Node.js, take some code to run Node, from cuda_lint_csslint linter.

=== Linters - per project ===

How to configure linters per project? In your project (Project Manager plugin), right-click root node of project treeview, call menu item "Project file / Project properties...". In this dialog, in the "Variablies" field, enter variable(s) like this:

 linter_css=csslint

Variable prefix "linter_" required, after goes lower-case lexer name (CSS). Value of variable must be name of linter's folder (in "py" folder) without "cuda_lint_". So if linter's folder is py/cuda_lint_aaa, specify value "aaa".

In this example, CudaLint plugin allows, for mentioned lexer CSS, only linter "csslint", even if another CSS linter (e.g. "csstree") is installed and found first.

== CudaFormatter ==
CudaFormatter is plugin which uses 2nd-level plugins, "formatters", to change the source code. Each "formatter" supports one or more lexers, and provides one or more actions. For example, the Addon Manager contains two formatters for XML: XML IndentX and XML Pretty Print.

For example, how to format code in XML?

* Use "Plugins / Addon Manager / Install" to install the CudaFormatter, and formatter(s) for XML. Restart CudaText.
* Open XML file.
* Use "Plugins / CudaFormatter / Formatter (menu)". This will show the menu of actions from appropriate formatter(s) for current file.

Formatters may change entire file text or only selected text. If selection is made, formatter changes only the selection, otherwise the entire text.

===CudaFormatter commands===

* Formatter (menu): Runs formatter for current editor file. If several formatters are found, menu dialog will suggest to choose one of them.

* Formatter A...D: Runs formatter for current editor file, which has label (A, B, C, D) set. Labels are configurable by another command.

* Configure on_save: Chooses which formatters are active on file saving. The first formatter, which is suitable for current lexer, and has the flag "on_save", will be used to format text on file saving.

* Configure labels: Allows to assign labels (A, B, C, D) to formatters. Labels allow to use commands "Formatter A"..."Formatter D", e.g. via hotkeys. So you can use command "Formatter A" via some hotkey, and be sure that for all lexers "Formatter A" will use desired formatters.

* Configure formatter: For those formatters which support config file, command will suggest to open global config file (in the folder "settings" of CudaText).

* Configure formatter (local): For those formatters which suppots config file, command will suggest to open "local" config (in the folder of current editor file). If local config not exists, plugin will suggest to create it from global config.

== External Tools ==

=== Introduction to External Tools ===

Plugin "External Tools" (ExtTools) can be installed from Addon Manager. It allows to run external programs, catch their output, and then it can:

* Display this output in the Output or Console panel of CudaText.
* Replace current editor selection with the output.
* Copy this output to a new document.
* Copy this output to Clipboard.
* And more.

Plugin adds "Tools" top menu (near "Plugins"), which has menu item "Config" to configure all tools (in the single dialog), and menu items to run all individual tools.

[[File:cudatext-tools-menuitem.png]]

Some external tools configs are shown in the Wiki topics below. Enter these strings in the "Tool properties" dialog.

[[File:cudatext-tools-props.png]]

Plugin allows to customize hotkeys for all individual tools, or to use the single hotkey for different tools. The single hotkey is the hotkey of the plugin's command "Tools / Run main lexer tool". What is the "main lexer tool"? For example, you have 2 tools for lexer C++, and 3 tools for lexer HTML. You open the "Tool properties" dialog for some C++ tool, and press "Set main" button to mark that tool as "main" for C++. Then you open properties of some HTML tool, press "Set main" button to mark that tool as "main" for HTML. So now the "Tools / Run main lexer tool" can determine what is the main tool for C++ and HTML.  

[[File:cudatext-tools-mainlexertool.png]]

Notes:

* The disadvantage of the plugin: it cannot show tool output lines immediately when they appear, it waits until tool is terminated. Use the [[#Runner]] plugin which supports that feature.
* If you see that running of tools makes the Output panel visible, you need to fix the "Capture output" option of those tools, set it to "Ignore".

=== Tool to compile by GCC ===

You can test how this tool works on any Linux, because GCC is preinstalled. Test the tool on C++ example, which is created from CudaText by menu "File / New from template / C++".

Properties:

* Name: C - compile
* File name: gcc
* Shell command: unchecked
* Parameters: "{FileNameOnly}" -o "{FileNameNoExt}"
* Initial folder: {FileDir}
* Lexers: C,C++
* Capture output: Output panel
* Encoding: utf_8

Optionally, configure "Pattern", so double click in the Output panel will put caret to the source code. Example of GCC error line in the Output panel, it will be handled by double click: "new.cpp:10:3: error: 'zz' was not declared in this scope".

* Pattern: (?P<file>[^:]+):(?P<line>\d+):(?P<col>\d+): .+

=== Tool to run C program ===

Tool is for Linux, so "File name" don't have an extension. For Windows, change "File name" field to "{FileNameNoExt}.exe".

Tool will catch the program output in the Output panel, program text input will not work.

* Name: C - run
* File name: "./{FileNameNoExt}"
* Shell command: checked
* Parameters: (empty)
* Initial folder: {FileDir}
* Lexers: C,C++
* Capture output: Output panel
* Encoding: utf_8
* Pattern: (empty)

=== Tool to run C program, on Windows, with input in terminal ===

Tool is for Windows, it allows to run compiled C/C++ program in new console window. Text input will work in this console.

Example C++ program:

<syntaxhighlight lang="C++">
#include <stdio.h>
int main ()
{
  int c;
  puts ("Enter text. Include a dot ('.') in a sentence to exit:");
  do {
    c=getchar();
    putchar (c);
  } while (c != '.');
  return 0;
}
</syntaxhighlight>

Tool props:
* Name: C - run
* File name: cmd
* Shell command: unchecked
* Parameters: /K "{FileNameNoExt}.exe"
** Alternative value: /C "{FileNameNoExt}.exe" && pause
* Initial folder: {FileDir}
* Lexers: C,C++
* Capture output: Ignore
* Encoding: utf_8
* Pattern: (empty)

=== Tool to run C program, on Linux, with input in terminal ===

Tool is for Linux, it allows to run compiled C/C++ program in new terminal window. Text input will work in this terminal window.

Example C++ program:

<syntaxhighlight lang="C++">
#include <stdio.h>
int main ()
{
  int c;
  puts ("Enter text. Include a dot ('.') in a sentence to exit:");
  do {
    c=getchar();
    putchar (c);
  } while (c != '.');
  return 0;
}
</syntaxhighlight>

Tool props:
* Name: C - run
* Variant for xterm:
** File name: xterm
** Parameters: -hold -e "./{FileNameNoExt}"
* Variant for gnome-terminal:
** File name: gnome-terminal
** Parameters: -- bash -c "./{FileNameNoExt}; read -s -n1 -r -p 'Press any key... '; echo"
* Shell command: unchecked
* Initial folder: {FileDir}
* Lexers: C,C++
* Capture output: Ignore
* Encoding: utf_8
* Pattern: (empty)

=== Tool to compile+run C program ===

In the External Tools dialog, press Join button, to join 2 tools created in above steps. Properties of joined tool:

* Name: C - make+run
* Series: C - compile; C - run
* Lexers: C,C++

=== Tool to run current Batch file ===

Tool properties:

* Name: Run batch file
* File name: cmd.exe
* Shell command: unchecked
* Parameters: /c "{FileName}"
* Initial folder: {FileDir}
* Lexers: Batch files
* Capture output: Output panel
* Encoding: the same as file's encoding: e.g. utf_8 or cp1251 (cp1251 is Russian ANSI codepage)

=== Tool to compile by Free Pascal ===

This tool is for Free Pascal 3.x on Linux x64.

Properties:

* Name: FPC - compile
* File name:
** for FPC installed system-wide: fpc
** for FPC installed via fpcupdeluxe: /home/user/fpcupdeluxe/fpcupdeluxe/fpc/bin/x86_64-linux/fpc.sh
* Shell command: unchecked
* Parameters: {FileNameOnly}
* Initial folder: {FileDir}
* Lexers: Pascal
* Capture output: Output panel
* Encoding: utf_8

Optionally, configure "Pattern", so double click in the Output panel will put caret to the source code. In the "Tool properties" dialog, press "Set" button near the "Pattern" and choose there ready preset for Free Pascal.

=== Tool to call file-compare utility ===

Tools, which call file-compare utility, to compare 2 files: active files in group-1 and group-2.

==== WinMerge, KDiff, Kompare====

* Name: Compare files in G1, G2
* File name: (full name of executable file)
* Shell command: unchecked
* Parameters: "{FileName_g1}" "{FileName_g2}"
* Initial folder: (empty)
* Capture output: Ignore

==== Meld ====

* Name: Compare files in G1, G2
* File name: (full name of executable file)
* Shell command: unchecked
* Parameters: --newtab "{FileName_g1}" "{FileName_g2}"
* Initial folder: (empty)
* Capture output: Ignore

==== diff ====

* Name: Compare files in G1, G2
* File name: diff
* Shell command: unchecked
* Parameters: -Nau "{FileName_g1}" "{FileName_g2}"
* Initial folder: (empty)
* Capture output: Copy to new document

=== Tool to run Python scripts ===

* Name: Python3
* File name:
** on Windows: full path to "python.exe"
** on Unix: python3
* Shell command:
** on Windows: checked
** on Unix: unchecked
* Parameters: "{FileNameOnly}"
* Initial folder: {FileDir}
* Lexers: Python
* Capture output: Output panel
* Encoding: utf_8
* Pattern: \s*File "(?P<file>.+)", line (?P<line>\d+)

=== Tool to preview HTML file in Chrome ===

* Name: Preview in Chrome
* File name:
** on Windows: C:\Program Files\Google\Chrome\Application\chrome.exe
* Shell command:
** on Windows: unchecked
* Parameters: "{FileName}"
* Initial folder: (empty)
* Lexers: HTML
* Capture output: Ignore

=== Tool to open PHP documentation with given topic ===

Tool to open PHP documentation, in .chm format, for the word under editor's caret. For Windows only. You need to install KeyHH from http://keyworks.helpmvp.com/ , it is stable tool mentioned on several sites. Program "keyhh.exe" will be in your system PATH.

Before making the tool, add "$" char to word chars for PHP lexer. To do it, call "Plugins / Options Editor", in the Options Editor dialog find option "word_chars" and set it to "$". You must save option to PHP lexer-specific config, so in the dialog you must check flag "For [x] Lexer", and choose lexer "PHP", and then write option value "$" and press Enter.

Download PHP documentation in .chm format from PHP.net, google for "php_manual_en chm", it is 16M file.

Tool properties:

* Name: PHP Help
* File name: keyhh.exe
* Shell command: unchecked
* Parameters: -MyHelp -#klink {CurrentWord} "C:\Work\php_manual_en.chm"
* Initial folder: (empty)
* Lexers: PHP
* Save before: Nothing
* Capture output: Ignore

=== Tool to open AutoIt documentation with given topic ===

Tool to open AutoIt documentation, in .chm format, for the word under editor's caret. For Windows only. You need to install KeyHH from http://keyworks.helpmvp.com/ , it is stable tool mentioned on several sites. Program "keyhh.exe" will be in your system PATH.

With AutoIt installed, you also have .chm documentation, its path is usually "C:\Program Files (x86)\AutoIt3\AutoIt.chm".

Tool properties:

* Name: AutoIt Help
* File name: keyhh.exe
* Shell command: unchecked
* Parameters: -MyHelp -#klink  {CurrentWord} "C:\Program Files (x86)\AutoIt3\AutoIt.chm"
* Initial folder: (empty)
* Lexers: AutoIt
* Save before: Nothing
* Capture output: Ignore

=== Tool to open .chm documentation for all lexers ===

See above example about tool for PHP documentation. Create the similar tool

* File name: keyhh.exe
* Shell command: unchecked
* Parameters: -MyHelp -#klink "{CurrentWord}" "{AppDir}\..\Docs\{Lexer}.chm"
* Lexers: (empty)

This tool needs renamed .chm files: for lexer AutoIt it needs "AutoIt.chm" and so on. It needs .chm files in a single folder relative to CudaText folder.

=== URL for Google search ===

This is URL, not tool. In the External Tools dialog, press URL button, then press Add to add a new URL.

* Name: Google find
* URL:

<syntaxhighlight lang="text">
http://google.com/search?q={SelectedText|q}
</syntaxhighlight>

=== Tool to open folder of current file in Windows Explorer ===

Tool properties:

* Name: Open cur dir in Explorer
* File name: explorer.exe
* Shell command: unchecked
* Parameters: {FileDir}
* Initial folder: {FileDir}

=== Tool to go to current file in FreeCommander ===

* Name: Go to file in FreeCommander
* File name: path\to\FreeCommander.exe
* Shell command: unchecked
* Parameters: "/L={FileName}" /C
* Initial folder: {FileDir}

=Runner=
Plugin Runner was written as an alternative to External Tools.

* Runner is more light weight.
* Runner supports Sublime Text 3 build-systems.
* Runner displays tool output immediately line-by-line as it appears (External Tools can only show the entire ready output).

Many build-systems from Sublime Text 3 were packaged and put to add-on collection, search for add-on "Many Build Systems".
Only few build-systems were packaged into own separate packages because they have big EXE/Binary files.
Some ST3 plugins have build-systems paired with some Python code - they are not supported.

See the [https://github.com/halfbrained/cuda_runner/blob/main/readme/readme.txt Runner documentation on GitHub].

Here is the GIF animation which shows reaction of Runner to PHP script running:
<syntaxhighlight lang="php">
<?php
for($i=0; $i<10; $i++) {
	sleep(1);
	echo "$i is here\n";
}
?>
</syntaxhighlight>

[[File:cudatext-runner-thread.gif]]

==Example C++ tool==
Install the add-on "build-system: C++ using G++".
It supports C++ lexer using GNU C++ compiler.
It works on Linux/macOS out-of-the-box, on Windows you need the command "g++" to be in the system PATH.

This build-system has 2 commands:
* compile, then run the compiled binary (default command)
* only run the compiled binary (it should be called from "Plugins / Runner / Build with...").

Example C++ file:
<syntaxhighlight lang="cpp">
#include <iostream>

int main() {
    std::cout << "Hello World!";
    return 0;
}
</syntaxhighlight>

Example output in the CudaText Output panel (Linux):
<pre>
-- [16:41:55] Building: C++: new.cpp
-- Command: g++ -std=c++11 -Wall "/home/user/new.cpp" -o "/home/user/new" && "/home/user/new"
-- Working dir: /home/user
Hello World!
-- Done (0.8s), return code: 0
</pre>

==Example PHP tool==
How to debug for example PHP file, with Runner.
Create file "[CudaText]/data/buildsystems/php.sublime-build" with such text:
<syntaxhighlight lang="json">
{
  "file_patterns": ["*.php"],
  "linux": {
    "cmd": ["php", "$file"]
  },
  "windows": {
    "cmd": ["C:\\PHP_folder\\php-win.exe", "$file"]
  }
}
</syntaxhighlight>

Restart CudaText.

After opening a PHP file, call Runner main command "Build", that's it. It must show script output (in the Output panel) line-by-line, as it appears.

Example script to test:
<syntaxhighlight lang="php">
<?php
for($i=0; $i<10; $i++) {
	sleep(1);
	echo "$i is here\n";
}
?>
</syntaxhighlight>

==Example Python tool==
How to debug for example Python file, with Runner.
Create file "[CudaText]/data/buildsystems/py.sublime-build" with such text:
<syntaxhighlight lang="json">
{
  "file_patterns": ["*.py"],
  "linux": {
    "cmd": ["python3", "$file"],
  },
  "windows": {
    "cmd": ["pythonw.exe", "$file"]
  }
}
</syntaxhighlight>

Restart CudaText.

After opening a Python file, call Runner main command "Build", that's it. It must show script output (in the Output panel) line-by-line, as it appears.

Example script to test:
<syntaxhighlight lang="python">
import sys
import time

def ForTest():
    for i in range(5):
        time.sleep(1)
        print(str(i) + " is here", flush=True)
        
if __name__ == '__main__':
    ForTest()
</syntaxhighlight>

==Example Free Pascal tool==
How to compile and run Free Pascal files.
Create file "[CudaText]/data/buildsystems/Free Pascal.sublime-build" with such text:
<syntaxhighlight lang="json">
{
  "file_patterns": ["*.pp", "*.pas"],
  "file_regex": "(.+?)\\((\\d+),(\\d+)\\)\\s(.+)$",
  "working_dir": "$file_path",
  "name": "Compile",
  "cmd": ["/home/user/fpcupdeluxe/fpcupdeluxe32/fpc/bin/x86_64-linux/fpc.sh", "$file_name"],
  "variants": [
    {
      "name": "Run",
      "cmd": ["./$file_base_name"]
    }
  ]
}
</syntaxhighlight>

Restart CudaText.

Here we use full path to FPC, when it is installed by FPCUPdeluxe tool on Linux x64. We use path of "fpc.sh" which is created by FPC installation.

After opening a Pascal file, call Runner main command "Build", that's it.
The "Build" command example output:

<pre>
-- [20:07:55] Building: Free Pascal: new.pas
-- Command: ['/home/user/fpcupdeluxe/fpcupdeluxe32/fpc/bin/x86_64-linux/fpc.sh', 'new.pas']
-- Working dir: /home/user
Free Pascal Compiler version 3.2.3-425-gebc55c0f4e-dirty [2021/09/09] for x86_64
Copyright (c) 1993-2021 by Florian Klaempfl and others
Target OS: Linux for x86-64
Compiling new.pas
Linking new
3 lines compiled, 0.1 sec
-- Done (0.2s), return code: 0
</pre>

The config above also gives the "Run" command for the compiled binary - in the menu of "Plugins / Runner / Build with...". The "Run" command example output:

<pre>
-- [20:09:09] Building: Free Pascal: new.pas
-- Command: ['./new']
-- Working dir: /home/user
Hello world.
-- Done (-0.0s), return code: 0
</pre>

=FindInFiles=
This plugin implements searching in many files, starting from custom folder. CudaText doesn't have the built-in feature to search in many files, and seems it will not have it in future, because FindInFiles is so powerful, it even has the Configuration dialog with dozens of options.

Project Manager plugin allows to call FindInFiles functionality. Focus a folder in Project Manager, call context menu, and then "Selected directory / Find in directory..." menu item.

==FiF3 and FiF4: comparison and future==
CudaText has two plugins to search in files/tabs:

* FindInFiles v3 (FiF3)
* FindInFiles v4 (FiF4)

Important: FiF3 is almost frozen. Only serious bugs will be fixed. No plans to hide/delete FiF3. FiF4 supersedes FiF3.

Detailed comparison.

Common features:

* Speed of search. Speed of FiF3 is stable. FiF4 can search faster or slower depending on the settings. In the "slow" mode FiF4 gives more complex Results or uses more complex filters.
* Encoding detection. FiF4 allows to set more flexible plan (see submenu "=/Encoding plan"). 
* Presets. Both versions allow to define and restore named set of search parameters. FiF4 allows to run dialog and start '''immediate search''' with parameters from a preset (see main menu command "Find by preset..."). FiF4 allows to restore [pre]previous parameters (runtime '''auto saving''').
* Results/Source. FiF3 allows to put Results in old/new tab or in dialog editor control. FiF4 allows to put Results only in dialog editor control and has a command to copy Results to new tab. Both allow to open the source file for specified fragment in new tab. FiF3 can place Results and Source vertically or horizontally. FiF4 has only one way.
* FiF3 has commands to '''count fragments''' and to show only filenames. FiF4 skips such commands as unnecessary.
* FiF3 can save '''dialog layouts'''. FiF4 saves layout as part of preset.
* Like FiF3, FiF4 has the "Replace" functionality.
* Like FiF3, FiF4 can search '''in project''' folder(s).

Main new features:

* FiF4 can report the found fragment with its '''around lines''' (see "-?+?" button).
* FiF4 can search '''multi-line fragments''' (see "+" button).
* FiF4 can search in '''many start folders'''.
* FiF4 allows to use '''lexer data''' to filter and report fragments (in/out string/comment, lexer path).
* FiF4 allows to show lines in the Results with its '''lexer colors''' from source files.
* FiF4 allows to use '''macro-variables''' (OS environments, properties of current file/tab and free-set names) in any editable fields . 
* FiF4 has '''statusbar''' to show statistics of the last search: folders/files/fragments/timing.
* FiF4 allows to '''reformat Results''' (change tree type and more) without new search.
* FiF4 allows to show '''modification time''' of files in the Results.

=Configure Menu=

Plugin "Configure Menu" (in Addon Manager) allows to change top menu and context menu. Plugin can create file (settings/menu.json) with default menu configuration, which you edit to customize all menus. File has items like:

 ,{"cap":"&Save", "cmd":"cmd_FileSave"}

How to add here built-in commands? See identifiers of CudaText commands in the file "py/cudatext_cmd.py", they have prefixes "cCommand_" (low level commands) and "cmd_" (high level commands). For example, "cmd_FileSave" is the command to save current file.

How to add here plugin commands? For example, you have plugin "Comments", it is in the folder "py/cuda_comments". See plugin's file install.inf, and find there needed Python methods. Then add in the "settings/menu.json" item like this:

 ,{"cap":"Toggle line comment", "cmd":"module=cuda_comments;cmd=cmt_toggle_line_body;"}

Here "cuda_comments" is plugin folder name, and "cmt_toggle_line_body" is Python method from install.inf.

You can add items to the CudaText top-menu and/or context-menu, it is different sections in "menu.json".
Example screenshot shows how "menu.json" will look with new items for context-menu:

[[File:cudatext-editing-context-menu.png]]

=Intext Bookmarks=

Plugin allows to place special marks, and to show Goto dialog for its special marks.
These are not usual CudaText bookmarks, but text lines, which are recognized only by this plugin.

Plugin adds menu items in "Plugins / In-text Bookmarks":

* List for current tab -- show all marks in the current document
* List for all tabs -- show all marks in all opened UI-tabs
* Go to next
* Go to previous 
* Add -- add a new mark at caret position

"Special" lines are supported even for files without lexer, and files with lexer if lexer doesn't support comments. For such poor files, plugin will add special lines like "//NOTE: comment_text".

You can customize that special lines, using plugin configuration dialog: menu item "Options / Settings-plugins / In-text Bookmarks". Dialog gives such options:

* Bookmark signs: NOTE: NB! TODO: todo: todo. FIX:
* Comment sign: //

That configuration means that for "poor" files (without lexer, or with lexer without line comments), plugin uses lines beginning with "//NOTE:" or "//NB!" or "//TODO:" etc.
For files with rich lexers, plugin uses lexer's line-comment prefix.

=Color Text=

Plugin "Color Text" gives several commands (in the Plugins menu) to add coloring to text ranges.
Plugin uses the selected text, without selection it uses word under first caret.
On applying the coloring, plugin marks file as "modified".
Plugin is suitable for files with any lexer, it adds its colors over the lexer highlight.

[[File:cudatext-color-text.png]]

The data of coloring is saved to additional 'helper file' with extension .cuda-colortext, in the folder of the original file. After you delete this 'helper file', plugin will not load its data on next start.

Not only background color can be changed, but also border color, and font styles (bold, italic, stikeout).
To specify colors/styles, you have to edit the plugin config file.
To edit the config file, call menu item "Options / Settings-plugins / Color Text".
Config file has sections for colors/styles, and usual options:

* "all_words": Colorize all occurrences of fragment.
* "case_sensitive": Case sensitive search for other occurrences.
* "whole_words": Colorize only those occurrences, which are whole words.
* "show_on_map": Show added colored marks also on micro-map.

=Insert Pics=
CudaText gives the plugin API to show pictures between the text lines.
These spaces between lines are called "gaps".
Plugin "Insert Pics" exists to show picture files in gaps.
It saves pictures in the helper files (using Base64 encoding), with extension .cuda-pic, 
near the original text file. Files with pictures look like this:

[[File:cudatext-insert-pics.png]]

* You can use any lexer for files with pictures.
* You can add the unlimited number of pictures. But only one picture per "gap".
* You can add/delete pictures later, using plugin's commands in menu "Plugins / Insert Pics".
* When you delete the "helper file" (located in the same folder), all pictures will be lost for plugin.

=Complete From Text=
Plugin allows to show auto-completion listbox with words from the current file (or all opened UI-tabs, by option).
E.g. if you typed "op" and press Ctrl+Space (default auto-completion hotkey), it may suggest previously mentioned words "operations", "opinion", "option" etc.
Plugin is not smart like "LSP Client" plugin, so expect lot of 'false positives' in its listbox.

[[File:cudatext-complete-from-text.png]]

In the picture above, one word was taken from C lexer's C.acp file (this is a feature).

Plugin is preconfigured to work with small set of lexers: none-lexer, Ini files, Markdown, reStructuredText, Properties. Here is how to use it for let's say "C" lexer:

* Install the plugin
* Call menu item "Options / Settings-plugins / Complete From Text"
* This opens the "plugins.ini" file
* Find section "[complete_from_text]", add ",c" (without quotes) to the line "lexers="
* Restart CudaText

Plugin has more options in that "plugins.ini" file:

* 'lexers': comma-separated lexer names, ie for which lexers to work; specify none-lexer as '-'.
* 'min_len': minimal word length, words of smaller length will be ignored.
* 'max_lines': if document has bigger count of lines, ignore this document.    
* 'case_sens': case-sensitive; words starting with 'A' will be ignored when you typed 'a'.
* 'no_comments': ignore words inside "syntax comments" (lexer specific).
* 'no_strings': ignore words inside "syntax strings" (lexer specific).
* 'what_editors': which documents (ie UI tabs) to read to get words. Values:
**    0: only current document.
**    1: all opened documents.
**    2: all opened documents with the same lexer.
* 'use_acp': add suggestions from autocomplete files in 'data/autocomplete'
* 'case_split': expands suggestions, autocompletion for 'AB' will include 'AzzBzz', so to get 'ValueError' just typing 'VE' (or 'VaE', 'VErr', 'ValErr' etc.) and calling on autocompletion will suggest it.
* 'underscore_split': expands suggestions, autocompletion for 'AB' will include 'AZZ_BZZ', so to get 'supports_bytes_environ' just typing 'sb' (or 'sbe', 'supbyenv' etc.) and calling on autocompletion will suggest it. 

Plugin supports CudaText option "nonword_chars", so for example words with '$' char are also added to completions, if CudaText option is configured so.

=Embedded Editor=

Plugin "Embedded Editor" shows "included" file in embedded editor - additional editor UI control is
shown between the text lines.
For example, you can open included CSS / JS files while editing the HTML file.

[[File:cudatext-embedded-editor.png]]

It adds menu item to show/hide embedded editor in the current document, for the
current caret position: "Plugins / Embedded Editor / Toggle".

By default, plugin searches for the included filename inside double-quotes,
surrounding the caret position. This works OK for HTML and many other documents.

For example, when you have opened file "/folder/file.html", and placed caret
inside first double-quotes:
<syntaxhighlight lang="html">
  <link href="css/style.css" rel="stylesheet" type="text/css"/>
</syntaxhighlight>
then embedded editor will be opened for file "/folder/css/style.css".

The search can be configured, though. For example, plugin can be used in Pascal
files for include-directives:
<syntaxhighlight lang="pascal">
  {$I path/filename.inc}
</syntaxhighlight>

Plugin has 2 config files, you will see 2 menu items in the 
"Options / Settings-plugins / Embedded Editor".
Read more about config files in the readme.txt of plugin.

=Breadcrumbs=

Plugin "Breadcrumbs" shows the toolbar widget (modern name is breadcrumb bar) below or on top of the editor for quick
file-system navigation. For example, when you have active editor with filename
"/home/user/mydir/myfile.ext", widget shows buttons:
<pre>
[ home / user / mydir / myfile.ext ]
</pre>
It can also show the "~" button for the home directory (by option):
<pre>
[ ~ / mydir / myfile.ext ]
</pre>

[[File:cudatext-breadcrumbs.png]]

Clicking on each button shows the popup with file-system listing, showing the
folder containing  the clicked item. This popup supports basic tree-view navigation,
you can click files there to open them in CudaText.

Plugin can also show buttons for Code-Tree nodes. This must be enabled first
in the config file - turn on the option "code_navigation".
Clicking the buttons from the code-tree shows the same tree-popup but with
a different content - with symbols of the documents. Clicking the nodes
in the tree-popup scrolls the document to different symbols.

=LSP Client=

Plugin "LSP Client" allows to use Microsoft LSP protocol in CudaText with servers for many languages. 
It requires that CudaText uses Python 3.6 or newer (otherwise you will see the error messagebox).

LSP Client gives several commands in the "Plugins / LSP Client", and all these commands work only if server supports them.
Some of LSP commands are:

* Auto-completion: integrated with CudaText command "Auto-completion menu" (in the Command Palette).
* Go to definition: integrated with CudaText command "Go to definition" (in the Command Palette, and in the editor context menu).
* Function signature help: integrated with CudaText command "Show function hint" (in the Command Palette).
* Hover: shows the tooltip when you hover mouse above identifiers. You need the Ctrl key pressed while you hover.

[[File:cudatext-lsp-hover_.png]]

* Find references: finds all locations where an identifier (under first caret) is used and shows menu with locations.

[[File:cudatext-lsp-refs.png]]

* Code linting: checks the syntax of code, and places underlines and/or bookmarks on "incorrect lines".
* Document formatting.

All LSP servers should have a homepage with description of their functions, and installation information.
LSP Client was initially tested with 2 popular servers: Python, C#.

In the server config "lsp_*.json", key "lexers", you need to specify the mapping between CudaText lexer names and LSP language names.
For example, while CudaText lexer name is "Bash script", LSP language name is "bash".
And while CudaText lexer name is "C#", LSP language name is "csharp".

<syntaxhighlight lang="json">
{
  "lexers": {
    "C#": "csharp"
  },
  ...
}
</syntaxhighlight>

LSP Client also has the settings file, use menu item to open it: "Options / Settings-plugins / LSP Client".

==LSP server for Python==
Python server has [https://github.com/palantir/python-language-server this homepage] and supports:

* Auto-completion
* Go to definition
* Function signature help
* Hover
* Find references
* Code linting
* Document formatting

Use "pip" to install the Python LSP server:

 pip install python-language-server
 
Server installation adds the command "pyls" which is not in the PATH.
You need to write the full path to LSP Client config.
Create the file "[CudaText]/settings/lsp_py.json" with text like this:

<syntaxhighlight lang="json">
{
  "lexers": {
    "Python": "python"
  },
  "cmd_windows": ["C:\\Python_folder\\pyls.exe"],
  "cmd_macos": ["pyls"],
  "cmd_unix": ["~/.local/bin/pyls"]
}
</syntaxhighlight>

Open some Python script, and call some commands of LSP Client. It will run the server, and it should work.

==LSP server for CSS/SCSS/LESS==

The CSS (and SCSS, LESS) server is not easy to install, so here is the instruction, from the author of LSP Client:

* Download the repository of VSCode: https://github.com/microsoft/vscode
* From the repository, get the folder "extensions/css-language-features/server" and enter in it.
* Replace the file "tsconfig.json" with content:
<syntaxhighlight lang="json">
{
    "compilerOptions": {
	    "target": "es2018",
	    "lib": [
		    "es2018"
	    ],
	    "module": "commonjs",
	    "strict": true,
	    "alwaysStrict": true,
	    "noImplicitAny": true,
	    "noImplicitReturns": true,
	    "noImplicitOverride": true,
	    "noUnusedLocals": true,
	    "noUnusedParameters": true,
	    "forceConsistentCasingInFileNames": true,
	    
	    "outDir": "./out"
    },
  "files": [
      "src/node/cssServerMain.ts"
  ]
}
</syntaxhighlight>

* Install dependencies and TypeScript. In Terminal:

 npm install
 npm install -g typescript

* Compile it. In Terminal:

 npx tsc

Server should be compiled. To use the server in LSP Client, create the file "lsp_css.json" with such content:
<syntaxhighlight lang="json">
{
    "name": "vsc-css",
    "lexers": {
    	"CSS": "css",
    	"SCSS": "scss",
    	"Sass": "sass",
    	"LESS": "less",
    },
    "cmd_unix": [
        "node",
        "path_to_server/server/out/node/cssServerMain.js",
        "--stdio"
    ]
}
</syntaxhighlight>

==LSP server for Nim==

Server from https://github.com/PMunch/nimlsp works good. Config "lsp_nim.json":

<syntaxhighlight lang="json">
{
    "name": "nim-lsp",
    "lexers": {
        "Nim": "nim"
    },
    "cmd_unix": [
      "~/.nimble/bin/nimlsp"
    ]
}
</syntaxhighlight>

==LSP server for Rust==

Q: I've successfully configured several language servers with this plugin, but rls ( https://github.com/rust-lang/rls ) seems to be unresponsive. Does this work for anyone else?

A: Seems to be a rls issue: https://github.com/rust-lang/rls/issues/536 . A workaround is to comment out the line in <cudatext>/py/cuda_lsp/sansio_lsp_client/io_handler.py, replace this:

        "Content-Type": f"application/vscode-jsonrpc; charset={encoding}",

with this

        #"Content-Type": f"application/vscode-jsonrpc; charset={encoding}",

==LSP server for AutoHotkey==

* Download the repository of AutoHotkey2: https://github.com/thqby/vscode-autohotkey2-lsp
* Extract and enter the directory: "vscode-autohotkey2-lsp-main" 
* Install dependencies and TypeScript. In Terminal:

 npm install
 npm install -g typescript

* Enter the directory "server", and compile the server. In Terminal:

 npx tsc

Server should be compiled now. To use the server in LSP Client, create the file "lsp_ahk.json" in the "settings" with such content:
<syntaxhighlight lang="json">
{
    "name": "AutoHotkey2",
    "lexers": {
        "AutoHotkey": "ahk"
    },
    "cmd_unix": [
        "node",
        "path_to_server/server/out/server.js",
        "--stdio"
    ]
}
</syntaxhighlight>

==LSP server for JavaScript/ReactJS==

* In "Addons Manager", install the lexer for ReactJS: "JavaScript Babel".
* Install TypeScript and the LSP server. In Terminal:

 npm install -g typescript typescript-language-server

To use the server in LSP Client, create a file "lsp_js.json" in the "settings" directory with such content:
<syntaxhighlight lang="json">
{
    "name": "JavaScript",
    "lexers": {
        "JavaScript": "javascript",
        "JavaScript Babel": "javascriptreact"
    },
    "cmd_unix": [
        "typescript-language-server",
        "--stdio"
    ]
}
</syntaxhighlight>

==LSP servers for C/C++==

Install one of the servers following the instructions:
* clangd: https://clangd.llvm.org/installation.html
* ccls: https://github.com/MaskRay/ccls/wiki/Build + https://github.com/MaskRay/ccls/wiki/Install

To use the server in LSP Client, create a file "lsp_c.json" in the "settings" directory with such content:
<syntaxhighlight lang="json">
{
  "lexers": {
    "C++": "cpp",
    "C": "c"
  },
  "cmd_unix": [
      "clangd-9",
  ],
}
</syntaxhighlight>

Replace "clangd-9" with "ccls" if it was chosen.

==LSP server for Red==

1) On Linux x64.

* Install Red. Download "red" binary, "chmod +x red", then copy it to PATH dir (/usr/bin on Ubuntu). Command "red" must work from Terminal. Red release 0.6.4 may give errors with the LSP server, so better install build from 30-Sep-2021.
* Install server from https://github.com/bitbegin/redlangserver, put the repo e.g. to ~/redlangserver.
* Create file "redlangserver.sh" and put it to some PATH dir. Content:

<syntaxhighlight lang="bash">
#!/bin/bash
red ~/redlangserver/server.red
</syntaxhighlight>

* Create file (CudaText)/settings/lsp_red.json with content:

<syntaxhighlight lang="json">
{
  "lexers": {
    "Red": "red"
  },
  "cmd_unix": ["redlangserver.sh"],
  "cmd_windows": ["c:\\red\\red.exe", "--cli", "c:\\red\\redlangserver\\server.red"]
}
</syntaxhighlight>

Server should work now. It gives: mouse hover tooltips (Ctrl + mouse hovering over names), go to definition.

2) On Windows 10 x64.

* Install Red to "c:\Red". Tested the build from 02-Oct-2021.
* Install server from https://github.com/bitbegin/redlangserver, put the repo to "c:\Red\redlangserver".
* Run once the command "c:\red\red.exe --cli", it will print "Compiling Red console..." with the big pause.
* Create file (CudaText)\settings\lsp_red.json with the same content as for Unix. Adjust path to Red folder, if needed.

Server should work now. It gives: mouse hover tooltips (Ctrl + mouse hovering over names), go to definition (works not always, logic when it works is unclear).

Note: don't create .bat or .cmd file with the "red.exe" calling, because it does not work in LSP Client for some reason. 

[[Category:CudaText]]
