=Intro=
This is API for [[CudaText]] in Python.

* Module: cudatext. Constants, functions, class Editor, objects of class Editor.
* Module: cudatext_cmd. Constants for Editor.cmd().
* Module: cudatext_keys. Constants for on_key.
* Module: cudax_lib. High-level functions for plugins, e.g. read/write configs.
* Module: cudax_nodejs. Helper functions for plugins which use Node.js.

=Event plugins=

To make plugin react to some program event, add method to class Command, and register this event in "install.inf" file of plugin. For example, method "on_save" will be called by program event "on_save" (plus install.inf must register "on_save"). Event methods have param "ed_self": this is Editor object in which event occured. This object is the same as object "ed" in most cases, but in some cases event occurs in inactive editor, e.g. command "Save all tabs" calls event "on_save" for inactive tabs.

Another way to react to program events is dynamic subscribing to events in runtime. This way you don't need to register methods in install.inf. See description of PROC_SET_EVENTS in app_proc(). 

Method return value is ignored is many cases, but sometimes return value True or False has special meaning. Usually the False return value blocks propagation of event to other plugins, so don't return False if not nessesary.

==General==

* on_open(self, ed_self): Called after file is opened from disk.
* on_open_pre(self, ed_self, filename): Called before file opening. Method can return False to disable opening, other value is ignored.
* on_open_none(self, ed_self): Called after file is opened, and none lexer was detected/set for it.
* on_close_pre(self, ed_self): Called before closing tab, before checking if tab modified or not. Method can return False to disable closing.
* on_close(self, ed_self): Called before closing tab, after modified file was saved, and editor is still active.
* on_save(self, ed_self): Called after saving file.
* on_save_pre(self, ed_self): Called before saving file. Method can return False to disable saving, other value is ignored.
* on_save_naming(self, ed_self): Called before saving untitled tab, to get suggested filename without path and extension. Method must return valid filename string or None.
* on_start(self, ed_self): Called once on program start (ignore ed_self).
* on_exit(self, ed_self): Called on exiting application. This event is lazy, ie it's called only for already loaded plugins.

==Tabs==

* on_tab_change(self, ed_self): Called after active tab is changed.
* on_tab_move(self, ed_self): Called after closing a tab (another tab is already activated), or moving a tab (by drag-n-drop, or UI command).

==Editor==

* on_change(self, ed_self): Called after editor text is changed.
* on_change_slow(self, ed_self): Called after editor text is changed, and few seconds (option) passed. Used in CudaLint plugin, it needs to react to change after a delay.
* on_caret(self, ed_self): Called after editor caret position and/or selection is changed.
* on_insert(self, ed_self, text): Called before inserting a text. Method can return False to disable insertion, other return value is ignored.
* on_key(self, ed_self, key, state): Called when user presses a key in editor. Param "key" is int key code; values are listed in the module cudatext_keys. Param "state" is string of chars: "a" if Alt pressed, "c" if Ctrl pressed, "s" if Shift pressed, "m" if Meta (Windows-key) pressed. Method can return False to disable key processing, other return value is ignored.
* on_key_up(self, ed_self, key, state): Called when user depresses a key in editor. Params meaning is the same as in "on_key". Currently called only for Ctrl/Shift/Alt keys (to not slow down).
* on_focus(self, ed_self): Called after any editor gets focus.
* on_lexer(self, ed_self): Called after editor's lexer is changed.
* on_lexer_parsed(self, ed_self): Called after lexer has finished its parsing. To not slow down usual work, event is called only if parsing time was >=600 msec.
* on_paste(self, ed_self, keep_caret, select_then): Called before some Clipboard Paste command runs. Parameters are options of various paste commands. Method can return False to disable default operation.
* on_scroll(self, ed_self): Called on scrolling in editor.
* on_mouse_stop(self, ed_self, x, y): Called when mouse cursor stops (for a short delay) over editor. Params "x", "y" are mouse editor-related coords.
* on_hotspot(self, ed_self, entered, hotspot_index): Called when mouse cursor moves in/out of hotspot. See ed.hotspots() API.
* on_state(self, ed_self, state): Called after some app state is changed. Param "state" is one of EDSTATE_nnnn or APPSTATE_nnnn constants.
* on_snippet(self, ed_self, snippet_id, snippet_text): Called when user chooses snippet to insert, in ed.complete_alt() call.

==Editor clicks==

* on_click(self, ed_self, state): Called after mouse click on text area. Param "state": same meaning as in on_key.
* on_click_dbl(self, ed_self, state): Called after mouse double-click on text area. Param "state": same meaning as in on_key. Method can return False to disable default processing.
* on_click_gutter(self, ed_self, state, nline, nband): Called on mouse click on gutter area. Param "state": same as in on_key. Param "nline": index of editor line. Param "nband": index of gutter band. Method can return False to disable default processing.
* on_click_gap(self, ed_self, state, nline, ntag, size_x, size_y, pos_x, pos_y): Called after mouse click on inter-line gap: see Editor.gap(). Param "state": same meaning as in on_key. Other params: properties of clicked gap.

==Smart commands==

* on_complete(self, ed_self): Called by auto-completion command (default hotkey: Ctrl+Space). Method should call Editor.complete API. Method must return True if it handled command, otherwise None.
* on_func_hint(self, ed_self): Called by function-hint command (default hotkey: Ctrl+Shift+Space). Method must return function-hint string (comma-separated parameters, brackets are optional). Empty str or None means no hint found.
* on_goto_def(self, ed_self): Called by go-to-definition command (in editor context menu). Method must return True if it handled command, otherwise None.
* on_goto_enter(self, ed_self, text): Called after user entered text in the Go To dialog. Method can return False to disable default processing.

==Panels==

* on_console_nav(self, ed_self, text): Called on double-clicking line, or calling context menu item "Navigate", in Python Console panel. Ignore ed_self. Param "text" is line with caret.
* on_output_nav(self, ed_self, text, tag): Called on clicking line, or pressing Enter, in the Output or Validate panel. Ignore ed_self. Param "text" is clicked line, param "tag" is int value associated with line. Event is called only if app cannot parse output line by itself using given regex, or regex is not set.

==Macros==

* on_macro(self, ed_self, text): Called when command "macros: stop recording" runs. In text the "\n"-separated list of macro items is passed. These items were run after command "macros: start recording" and before command "macros: stop recording".
** if item is "number" then it's simple command.
** if item is "number,string" then it's command with str parameter (usually it's command cCommand_TextInsert).
** if item is "py:string_module,string_method,string_param" then it's call of Python plugin (usually string_param is empty).

Note: To run each on_macro item (with number) later, call ed.cmd(): number is command code, string after comma is command text.

==Events priority==

By default all events in all plugins have prior=0. So for any event, if 2+ plugins have this event, they're called in order on module names (e.g. cuda_aa, then cuda_dd, then cuda_mmm).

You may want to handle some event first.
To change prior for your plugin event, write in install.inf event like this: "on_key+", "on_key++"... with any number of "+" up to 4. Each "+" makes higher prior. So first called "on_key" with maximal number of "+", last called "on_key" w/o "+".

==Lazy events==

By default all event handlers, except on_exit, are not "lazy". On_exit is always "lazy" - it means that it's called only for already loaded plugins. To make other event handlers lazy, write in install.inf event name with "~":

 events=on_focus~,on_open~,on_state~

It's allowed to combine "+" and "~" suffixes, like on_focus~++

=Callback param=

Callback parameter is supported in several API functions: dlg_proc, timer_proc, menu_proc, button_proc (maybe more later).

Parameter can be in these forms:

* callable, i.e. name of a function
* string "module=mmm;cmd=nnn;" - to call method nnn (in class Command) in plugin mmm, where mmm is usually sub-dir in the "cudatext/py", but can be any module name
* string "module=mmm;cmd=nnn;info=iii;" - the same, and callback will get param "info" with your value
* string "mmm.nnn" - the same, to call method, short form
* string "module=mmm;func=nnn;" - to call function nnn in root of module mmm
* string "module=mmm;func=nnn;info=iii;" - the same, and callback will get param "info" with your value

For example:

* If you need to call function "f" from plugin cuda_my, from file "py/cuda_my/__init__.py", callback must be "module=cuda_my;func=f;"
* If you need to call it from file "py/cuda_my/lib/mod.py", callback must be "module=cuda_my.lib.mod;func=f;".

Value after "info=" can be of any type, e.g. "info=20;" will pass int 20 to callback, "info='my';" will pass string 'my'.

=Global funcs=

===version===

 app_exe_version()

Gets version of program (string).

 app_api_version()

Gets version of API (string, contains 3 numbers, dot-separated).

Example of version check:

<syntaxhighlight lang="python">
  from cudatext import *

  if app_api_version() < '1.0.140':
      msg_box('Plugin NN needs newer app version', MB_OK+MB_ICONWARNING)
</syntaxhighlight>

===app_path===

 app_path(id)

Gets file-system path. Possible values of "id":

* APP_DIR_EXE: Dir of program executable.
* APP_DIR_SETTINGS: Dir "settings".
* APP_DIR_DATA: Dir "data".
* APP_DIR_PY: Dir "py" with Python files.
* APP_DIR_INSTALLED_ADDON: Dir of last installed addon (for plugins it is folder in "py", for data-files it is folder in "data", for lexers it is folder "lexlib"). This dir is updated only if addon installed via file_open() or from app (Open dialog or command line).
* APP_FILE_SESSION: Filename of current session. Default filename is "history session.json" without path. Missing path means that folder "settings" will be used.
* APP_FILE_RECENTS: Str: "\n"-separated filenames of recent files.

Note: to get path of dir "settings_default", use base dir of "settings".

===app_proc===

 app_proc(id, text)

Performs application-wide action.

Parameter "text" is usually string, but can be of other types (bool, int, float, tuple/list of simple types).

====Misc properties====

* PROC_GET_LANG: Gets string id of active app translation. E.g. "ru_RU" if translation file is "ru_RU.ini", or "translation template" if such file is used. Gets empty string if built-in English translation is used.
* PROC_GET_GROUPING: Gets grouping mode in program, one of GROUPS_nnnn int contants.
* PROC_SET_GROUPING: Sets grouping mode in program, one of GROUPS_nnnn int contants.
* PROC_PROGRESSBAR: Changes state of the progress-bar (hidden by default), which is located on the status-bar right corner. Int value<0: progressbar hides, value in 0..100: progressbar shows with the given value.
* PROC_GET_TAB_IMAGELIST: Gets int handle of imagelist, for file-tabs. Use imagelist_proc() to work with it. Use PROP_TAB_ICON property to get/set file-tab icon index (index in this imagelist).
* PROC_GET_CODETREE: Gets int handle of code-tree UI control. Use tree_proc() to work with it.
* PROC_WINDOW_TOPMOST_GET: Gets bool flag: main window has "always on top" style.
* PROC_WINDOW_TOPMOST_SET: Sets bool flag: main window has "always on top" style.

* PROC_CONFIG_READ: Reads param "text" as contents of CudaText JSON config file.
* PROC_CONFIG_NEWDOC_EOL_GET: Gets str: line endings of newly created documents (app option "newdoc_ends").
* PROC_CONFIG_NEWDOC_EOL_SET: Sets str: line endings of newly created documents.
* PROC_CONFIG_NEWDOC_ENC_GET: Gets str: encoding of newly created documents (app option "newdoc_encoding").
* PROC_CONFIG_NEWDOC_ENC_SET: Sets str: encoding of newly created documents.

====Search properties====

Actions work with props of Find/Replace dialog, and props of low-level search engine. When user runs some search command in the dialog, dialog applies its props to the search engine. So most of the time, props of dialog and search engine are sync'ed. But they aren't sync'ed if user just typed new text in the dialog. They also aren't sync'ed if user runs some search command via Command Palette or hotkey (e.g. "find current word, previous").

* PROC_GET_FINDER_PROP: Gets properties of Find/Replace dialog and search engine. Gets dict with keys:
** "find": string "what to find" of search engine
** "rep": string "replace with" of search engine
** "find_d": string "what to find" of dialog, None if dialog not inited
** "rep_d": string "replace with" of dialog, None if dialog not inited
** "op_case": option "case sensitive" of search engine
** "op_word": option "whole words" of search engine
** "op_regex": option "reg.ex." of search engine
** "op_cfm": option "confirm on replace" of search engine
** "op_insel": option "in selection" of search engine
** "op_wrap": option "wrapped search" of search engine
** "op_back": option "backward search" (low level) of search engine
** "op_fromcaret": option "search from caret" (low level) of search engine
** "op_tokens": option "allowed syntax elements" of search engine (int)
** "op_case_d": option "case sensitive" of dialog, None if dialog not inited
** "op_word_d": option "whole words" of dialog, None if dialog not inited
** "op_regex_d": option "reg.ex." of dialog, None if dialog not inited
** "op_cfm_d": option "confirm on replace" of dialog, None if dialog not inited
** "op_insel_d": option "in selection" of dialog, None if dialog not inited
** "op_wrap_d": option "wrapped search" of dialog, None if dialog not inited
** "op_mulline_d": option "multi-line input fields" of dialog, None if dialog not inited
** "op_tokens_d": option "allowed syntax elements" of dialog (int), None if dialog not inited

* PROC_SET_FINDER_PROP: Sets properties of Find/Replace dialog and search engine. Param "text" must be dict, with all or some keys listed in PROC_GET_FINDER_PROP. Values types: str (for text fields), bool (for flags), int (for choices).

====System====

* PROC_ENUM_FONTS: Gets list of font names, currently installed in OS. Note: only some names are common in all OSes (like Arial, Courier, Courier New, Terminal, maybe more).
* PROC_GET_SYSTEM_PPI: Gets int value of screen pixels-per-inch. Usual value is 96. When OS UI is scaled, it's bigger, e.g. for scale 150% it is round(96*1.5).
* PROC_GET_GUI_HEIGHT: Gets height (pixels) of GUI element for dlg_custom(). Possible values of 'text': 'button', 'label', 'linklabel', 'combo', 'combo_ro', 'edit', 'spinedit', 'check', 'radio', 'checkbutton', 'filter_listbox', 'filter_listview'. Special value 'scrollbar' gets size of OS scrollbar. Gets None for other values.
* PROC_GET_MOUSE_POS: Gets mouse cursor position in screen-related coordinates, as (x, y) tuple.
* PROC_SEND_MESSAGE: For Windows. Sends message to a window by its handle. Param "text" must be 4-tuple of int (window_handle, msg_code, param1, param2).

====Clipboard====

* PROC_GET_CLIP: Gets clipboard text.
* PROC_SET_CLIP: Copies text to clipboard (usual).
* PROC_SET_CLIP_ALT: Copies text to alternate clipboard on Linux, called "primary selection".
** CudaText Copy commands put text to usual clipboard + primary selection.
** CudaText Paste commands get text from usual clipboard.
** CudaText Paste with option "mouse_mid_click_paste":true gets text from primary selection.

====Plugin calls====

* PROC_SET_EVENTS: Subscribes plugin to events. It removes all subscribed events (even those from install.inf file) and then adds specified events (if list not empty). Param "text" must be 4 values ";"-separated: "module_name;event_list;lexer_list;keycode_list".
** event_list is comma-separated event names. e.g. "on_open,on_save", or empty str to unsubscribe from all.
** lexer_list is comma-separated lexer names.
** keycode_list is comma-separated int key codes, it can be used when on_key event was specified (event will fire only for specified key codes).
* PROC_GET_LAST_PLUGIN: Gets info about last plugin which run from program. It is str "module_name,method_name", values are empty if no plugins run yet.
* PROC_SET_SUBCOMMANDS: Adds command items for plugin (for fixed module/method). Param text must be ";"-separated: "module_name;method_name;param_list". Param_list is "\n"-separated items. Each item is s_caption+"\t"+s_param_value. s_caption is caption for Commands dialog item, s_param_value is parameter for Python method (it can be any primitive type: 20, None, False, 'Test here', or expression).

* PROC_GET_COMMANDS: Gets list of all commands, as list of dict. Dict keys are:
** "type": str: Possible values: "cmd" (usual command), "lexer" (dynamically added command to activate lexer), "plugin" (dynamically added plugin command).
** "cmd": int: Command code, to use in ed.cmd() call.
** "name": str: Pretty name, which is visible in the Commands dialog.
** "key1": str: Hotkey-1.
** "key2": str: Hotkey-2.
** "key1_init": str: Hotkey-1 from built-in config.
** "key2_init": str: Hotkey-2 from built-in config.
** (for plugins) "p_caption": str: Menu-item caption from install.inf.
** (for plugins) "p_module": str: Python module.
** (for plugins) "p_method": str: Python method in Command class.
** (for plugins) "p_method_params": str: Optional params for Python method.
** (for plugins) "p_lexers": str: Comma-separated lexers list.
** (for plugins) "p_from_api": bool: Shows that command was generated from API by some plugin.
** (for plugins) "p_in_menu": str: Value of parameter "menu" from install.inf.

====Hotkeys====

* PROC_GET_ESCAPE: Gets Esc-key flag (bool). This flag is set when user presses Esc key, each Esc press is counted since app start. Note: to allow app to handle key press in long loop, call msg_status('text', True).
* PROC_SET_ESCAPE: Sets Esc-key flag. Param "text" must be bool (or "0"/"1").
* PROC_GET_HOTKEY: Gets hotkeys strings for given command_id. Examples of result: "F1", "Ctrl+B * B", "Ctrl+B * B * C|Ctrl+B * D" (two hotkeys for one command). Gets empty str for unknown command_id.
* PROC_SET_HOTKEY: Sets hotkeys for given command_id from strings. Text must be "command_id|hotkey1|hotkey2", where hotkey1/hotkey2 examples: "F1", "Ctrl+B * B", "Ctrl+B * B * C". Symbol "*" can be without near spaces. Gets bool: command_id exists, changed.
* PROC_GET_KEYSTATE: Gets state of pressed keyboard keys and mouse buttons. String result has chars:
** "c" for Ctrl
** "a" for Alt
** "s" for Shift
** "m" for Meta (Windows key)
** "L" for left mouse button
** "R" for right mouse button
** "M" for middle mouse button
* PROC_HOTKEY_STR_TO_INT: Converts given string hotkey to int. Gets 0 for incorrect string. Example: converts "alt+shift+z" to 41050.
* PROC_HOTKEY_INT_TO_STR: Converts given int hotkey to string. Gets empty str for unknown code. Example: converts 41050 to "Shift+Alt+Z".

Notes:

* Value of command_id can be: str(int_command_code) or "module,method" or "module,method,param".

====Python====
* PROC_EXEC_PYTHON: Runs Python string in the context of Console (it is not the same as exec() call). Also gets string: result of command.
* PROC_EXEC_PLUGIN: Runs Python plugin's method. Text must be ","-separated: "module_name,method_name,param_string", where param_string can be missed, this is parameter(s) for method.

====Themes====

Notes:
* Theme names are short strings, lowercase, e.g. "cobalt", "sub". Empty string means built-in theme.
* Setting default theme (empty str) resets both UI + syntax themes.
* To enumerate themes, you need to list themes folder.

Actions:

* PROC_THEME_UI_GET: Gets name of UI-theme.
* PROC_THEME_UI_SET: Sets name of UI-theme.
* PROC_THEME_SYNTAX_GET: Gets name of syntax-theme.
* PROC_THEME_SYNTAX_SET: Sets name of syntax-theme.

* PROC_THEME_UI_DATA_GET: Gets contents of current UI-theme, as list of dict.
* PROC_THEME_SYNTAX_DATA_GET: Gets contents of current syntax-theme, as list of dict.

====Sessions====

Session is a set of opened files + untitled tabs, with some properties of editors in these tabs, with group-indexes of tabs, with layout of groups. Session format is JSON.

* PROC_SAVE_SESSION: Saves session to file with given name. Gets bool: session was saved.
* PROC_LOAD_SESSION: Loads session from file with given name (closes all tabs first). Gets bool: tabs closed w/o pressing Cancel, session was loaded.
* PROC_SET_SESSION: Tells to app filename of session. Session with this filename will be saved on exit, loaded on start, shown in app title in {} brackets. Don't set here empty string. Default filename is "history session.json" without path. Missing path means that folder "settings" will be used.

====Side panel====

* PROC_SIDEPANEL_ADD_DIALOG: Adds tab, with embedded dialog, to sidebar. Gets bool: params correct, tab was added. Text must be 3-tuple (tab_caption, id_dlg, icon_filename):
** Caption of tab (must not contain ",")
** Handle of dialog, from dlg_proc()
** Name of icon file (must not contain ",")

* PROC_SIDEPANEL_REMOVE: Removes tab. Text is caption of tab. (Note: actually it hides tab, dialog for this tab is still in memory). Gets bool: tab was found/removed.
* PROC_SIDEPANEL_ACTIVATE: Activates tab in sidebar. Gets bool: tab was found/activated. Text can be:
** str: tab_caption.
** 2-tuple (tab_caption, bool_set_focus). Default for bool_set_focus is False.
* PROC_SIDEPANEL_ENUM: Enumerates tabs. Gets str, "\n"-separated captions of tabs.
* PROC_SIDEPANEL_GET_CONTROL: Gets int handle of dialog, inserted into tab. Text is caption of tab. Gets None if cannot find tab.
* PROC_SIDEPANEL_GET: Gets caption of last activated tab.

Notes:

* Name of icon file: name of png/bmp file. Icon size should be equal to size of current sidebar icon set, it's default is 20x20 (to detect size of icon set, you can read and parse CudaText option). If filename is without path, CudaText sub-dir "data/sideicons" is used (so only a standard icon name can be without path).

==== Bottom panel====

* PROC_BOTTOMPANEL_ADD_DIALOG: Adds tab. Same as for PROC_SIDEPANEL_ADD_DIALOG.
* PROC_BOTTOMPANEL_REMOVE: Removes tab. Same as for PROC_SIDEPANEL_REMOVE.
* PROC_BOTTOMPANEL_ACTIVATE: Activates tab. Same as for PROC_SIDEPANEL_ACTIVATE.
* PROC_BOTTOMPANEL_ENUM: Enumerates tabs. Same as for PROC_SIDEPANEL_ENUM.
* PROC_BOTTOMPANEL_GET_CONTROL: Gets int handle of control. Same as for PROC_SIDEPANEL_GET_CONTROL.
* PROC_BOTTOMPANEL_GET: Gets caption of last activated tab. Same as for PROC_SIDEPANEL_GET.

====Splitters====

Splitter id:

* SPLITTER_SIDE: splitter near side panel.
* SPLITTER_BOTTOM: splitter above bottom panel.
* SPLITTER_G1 .. SPLITTER_G5: splitters between groups.

Actions:

* PROC_SPLITTER_GET: Gets info about splitter, as 4-tuple: (bool_vertical, bool_visible, int_pos, int_parent_panel_size). Param "text" is int splitter id.
* PROC_SPLITTER_SET: Sets splitter pos. Param "text" is 2-tuple (int_splitter_id, int_splitter_pos).

Positions of group splitters (G1, G2, G3, G4, G5) are determined by grouping view, in one view splitter may be horizontal with one parent panel, in other view - vertical with another parent panel. Detailed:

<pre>
2VERT     t G1 t

2HORZ     t
          G1
          t

3VERT     t G1 t G2 t

3HORZ     t
          G1
          t
          G2
          t

1P2VERT    t G3 t
               G2
                t

1P2HORZ    t
           G3
           t G2 t

4VERT     t G1 t G2 t G3 t

4HORZ     t
          G1
          t
          G2
          t
          G3
          t

4GRID     t G1 t
          G3
          t G2 t

6VERT     t G1 t G2 t G3 t G4 t G5 t

6HORZ     t
          G1
          t
          G2
          t
          G3
          t
          G4
          t
          G5
          t

6GRID     t G1 t G2 t
          G3
          t G1 t G2 t
</pre>

====Show/Hide/Undock UI elements====

Actions can get/set state of UI elements (pass "0"/"1" or False/True):

* PROC_SHOW_STATUSBAR_GET
* PROC_SHOW_STATUSBAR_SET
* PROC_SHOW_TOOLBAR_GET
* PROC_SHOW_TOOLBAR_SET
* PROC_SHOW_SIDEBAR_GET
* PROC_SHOW_SIDEBAR_SET
* PROC_SHOW_SIDEPANEL_GET
* PROC_SHOW_SIDEPANEL_SET
* PROC_SHOW_BOTTOMPANEL_GET
* PROC_SHOW_BOTTOMPANEL_SET
* PROC_SHOW_TABS_GET
* PROC_SHOW_TABS_SET
* PROC_SHOW_TREEFILTER_GET
* PROC_SHOW_TREEFILTER_SET
* PROC_SHOW_FLOATGROUP1_GET
* PROC_SHOW_FLOATGROUP1_SET
* PROC_SHOW_FLOATGROUP2_GET
* PROC_SHOW_FLOATGROUP2_SET
* PROC_SHOW_FLOATGROUP3_GET
* PROC_SHOW_FLOATGROUP3_SET

* PROC_FLOAT_SIDE_GET
* PROC_FLOAT_SIDE_SET
* PROC_FLOAT_BOTTOM_GET
* PROC_FLOAT_BOTTOM_SET

====Screen coordinates====

Notes:

* When getting or setting coords, you get/set 4-tuple of int: (left, top, right, bottom).

Actions:

* PROC_COORD_WINDOW_GET: Gets coords of app window.
* PROC_COORD_WINDOW_SET: Sets coords of app window.
* PROC_COORD_DESKTOP: Gets coords of virtual desktop, which includes all monitors.
* PROC_COORD_MONITOR: Gets coords of monitor with app window.
* PROC_COORD_MONITOR0: Gets coords of 1st monitor.
* PROC_COORD_MONITOR1: Gets coords of 2nd monitor, or None if no such monitor.
* PROC_COORD_MONITOR2: Gets coords of 3rd monitor, or None if no such monitor.
* PROC_COORD_MONITOR3: Gets coords of 4th monitor, or None if no such monitor.

===app_log===

 app_log(id, text, tag=0, panel="")

Performs action with standard panels in the bottom panel: Output, Validate, Console.

Possible values of "panel":

* value LOG_PANEL_OUTPUT: Output panel
* value LOG_PANEL_VALIDATE: Validate panel

Possible values of "id" for Output/Validate panels:

* LOG_CLEAR: Clears log panel. Param "text" ignored.
* LOG_ADD: Adds line to log panel. Param "tag" is used here: int value associated with line, it's passed in on_output_nav.
* LOG_SET_REGEX: Sets parsing regex for log panel. Param "text". Regex must have some groups in round brackets, indexes of these groups must be passed in separate API calls. All lines in log panel, which can be parsed by this regex, will allow navigation to source code by click or double-click.
* LOG_SET_LINE_ID: Sets index of regex group for line-number. Param "text" is one-char string from "1" to "8", and "0" means "not used".
* LOG_SET_COL_ID: Sets index of regex group for column-number. Param "text".
* LOG_SET_NAME_ID: Sets index of regex group for file-name. Param "text".
* LOG_SET_FILENAME: Sets default file name, which will be used when regex cannot find file name in a string. Param "text".
* LOG_SET_ZEROBASE: Sets flag: line and column numbers are 0-based, not 1-based. Param "text" is one-char string "0" or "1".
* LOG_GET_LINES_LIST: Gets items in panel's listbox, as list of 2-tuples (line, tag).
* LOG_GET_LINEINDEX: Gets index of selected line in panel's listbox.
* LOG_SET_LINEINDEX: Sets index of selected line in panel's listbox.

Possible values of "id" for "Console" panel:

* LOG_CONSOLE_CLEAR: Clears UI controls in console.
** If text empty or has "m" then memo-control (above) is cleared.
** If text empty or has "e" then edit-control (below) is cleared.
** If text empty or has "h" then combobox history list is cleared.
* LOG_CONSOLE_ADD: Adds line to console (its combobox and memo).
* LOG_CONSOLE_GET_COMBO_LINES: Gets list of lines in combobox-control.
* LOG_CONSOLE_GET_MEMO_LINES: Gets list of lines in memo-control.

====Example====

For line "line 10 column 20: text message here" the following regex and indexes can be used:

* regex "\w+ (\d+) \w+ (\d+): .+"
* line-number index "1"
* column-number index "2"
* file-name index "0" (not used)
* zero-base flag "0" (off)

===app_idle===

 app_idle(wait=False)

Performs application's message-processing. If wait=True, also waits for new UI event.

===emmet===

 emmet(id, text, p1="", p2="")

Performs action with embedded Emmet engine. Possible values of "id":

* EMMET_EXPAND: Expand abbreviation. Gets 2-tuple (str_result, bool_multi_caret) or None.
** Param "text": Emmet abbreviation.
** Param "p1": Emmet syntax. Possible values: "html", "xml", "xsl", "css", "svg", "sass", "less". 

* EMMET_WRAP: Wrap text with abbreviation. Gets str result or None.
** Param "text": Emmet abbreviation.
** Param "p1": Emmet syntax.
** Param "p2": Text to wrap. Can be multi-line with LF line breaks.

* EMMET_GET_POS: Find beginning of abbreviation in given string. Gets offset in string (0-based), or None.
** Param "text": Text string (can include unneeded text after caret position, can include HTML tags before abbreviation).
** Param "p1": Caret offset (0-based) to search abbreviation to the left of it. 

===msg_box===

 msg_box(text, flags)

Shows modal message-box.

Param "text" is message text. Multi-line text with "\n" is supported.

Param "flags" is sum of button-value (OK, OK/Cancel, Yes/No etc):
* MB_OK
* MB_OKCANCEL
* MB_ABORTRETRYIGNORE
* MB_YESNOCANCEL
* MB_YESNO
* MB_RETRYCANCEL

and icon-value:
* MB_ICONERROR
* MB_ICONQUESTION
* MB_ICONWARNING
* MB_ICONINFO

Gets int code of pressed button (gets ID_CANCEL if dialog cancelled):

* ID_OK
* ID_CANCEL
* ID_ABORT
* ID_RETRY
* ID_IGNORE
* ID_YES
* ID_NO

===msg_box_ex===

 msg_box_ex(caption, text, buttons, icon)

Shows modal message-box with any number of buttons.

* Param "caption": str: Caption of dialog.
* Param "text": str: Message text. Multi-line text with "\n" is supported.
* Param "buttons": list of str: Non-empty list of button captions. Multi-line captions are not supported on Windows.
* Param "icon": int: Icon in dialog, one of constants:
** MB_ICONERROR
** MB_ICONQUESTION
** MB_ICONWARNING
** MB_ICONINFO

Gets int index of pressed button (0-based), or None of cancelled.

===msg_status===

 msg_status(text, process_messages=False)

Shows given text in statusbar.

Param "process_messages": if True, function also does UI messages processing. It takes some time, it is needed to refresh status of Esc-key pressed. After call msg_status(..., True) you can get state of Esc-key pressed via PROC_GET_ESCAPE, otherwise plugin gets an old state, until UI messages are processed.

===msg_status_alt===

 msg_status_alt(text, seconds)

Shows given text in the floating tooptip on the top. Multi-line text (with "\n") is supported.

Param "seconds": show pause in seconds, 1..30. Value<=0 hides the tooltip.

===dlg_input===

 dlg_input(label, text)

Shows modal dialog to input one string. Gets entered string or None if cancelled.

* Param "label": prompt text above input field.
* Param "text": initial value of input field.

===dlg_input_ex===

 dlg_input_ex(number, caption,
               label1   , text1="", label2="", text2="", label3="", text3="",
               label4="", text4="", label5="", text5="", label6="", text6="",
               label7="", text7="", label8="", text8="", label9="", text9="",
               label10="", text10="")

Shows modal dialog to enter 1 to 10 string fields at once. Gets list of strings or None if cancelled.

* Param "number": count of input fields.
* Params "label": prompt text above input field.
* Params "text": initial value of input field.

===dlg_file===

 dlg_file(is_open, init_filename, init_dir, filters, caption="")

Shows file-open or file-save-as modal dialog. Gets filename (str) or None if cancelled.

* Param "is_open": True for open dialog, False for save-as dialog.
* Param "init_filename": Initial filename for save-as dialog. Can be empty.
* Param "init_dir": Initial folder. Can be empty.
* Param "filters": File filters string. Can be empty. Example for 2 filters: "Source codes|*.pas;*.inc|Text files|*.txt"
* Param "caption": Dialog caption. If empty, default value is used: "Open file", "Save file".

Features:

* To allow multi-select in open dialog, pass init_filename="*". If single filename selected, result is str. If several filenames selected, result is list of str.
* To disable check "filename exists" in open dialog, start init_filename with "!".

===dlg_dir===

 dlg_dir(init_dir, caption="Select folder")

Shows dialog to select folder path. Gets path (str), or None if cancelled.

* Param "init_dir": Initial folder.
* Param "caption": Dialog caption.

===dlg_menu===

 dlg_menu(id, items, focused=0, caption="")

Shows menu-like dialog. Gets index of selected item (0-based), or None if cancelled.

Possible values of "id":

* MENU_LIST: Dialog with listbox and filter.
* MENU_LIST_ALT: Dialog with listbox and filter, but each item has double height, and instead of right-aligning, 2nd part of an item shows below.

You can add to "id" values:

* MENU_NO_FUZZY: Disable fuzzy search in the items list.
* MENU_NO_FULLFILTER: Disable filtering by second part of items (after "\t"), filter only by first part.
* MENU_CENTERED: Show menu centered on screen (otherwise it's aligned to current editor).

Parameters:

* Param "items": Menu items, can be list of str, tuple of str, or string with "\n"-separated parts. Each item can be simple string or part1+"\t"+part2, where part2 shows right-aligned or below.
* Param "focused": Index of initially selected item.
* Param "caption": If not empty string, it is dialog caption.

===dlg_color===

 dlg_color(value)

Shows select-color dialog with given initial color (int).

Gets int color, or None if cancelled.

===dlg_hotkey===

 dlg_hotkey(title="")

Shows dialog to press single hotkey.

Gets str of hotkey (e.g. "F1", "Ctrl+Alt+B") or None if cancelled.

===dlg_hotkeys===

 dlg_hotkeys(command, lexer="")

Shows dialog to configure hotkeys of internal command or plugin. Gets bool: OK pressed and hotkeys saved (to keys.json).

Param command can be:

* str(int_command): for internal command codes (module cudatext_cmd).
* "module_name,method_name" or "module_name,method_name,method_param": for command plugin.

Param lexer is optional lexer name. If not empty, dialog enables checkbox "For current lexer" and (if checkbox checked) can save hotkey to "keys lexer NNNN.json".

===dlg_custom===

 dlg_custom(title, size_x, size_y, text, focused=-1, get_dict=False)

Shows dialog with controls of many types.

====Types====

Types of UI controls:

* "button": simple button
* "label": simple read-only text
* "check": checkbox, checked/unchecked/grayed
* "radio": radio-button, only one of radio-buttons can be checked
* "edit": single-line input
* "edit_pwd": single-line input for password, text is masked
* "combo": combobox, editable + drop-down, value is text
* "combo_ro": combobox, drop-down only, value is index of drop-down
* "listbox": list of items with one item selected
* "checkbutton": looks like button, but don't close dialog, checked/unchecked
* "memo": multi-line input
* "checkgroup": group of check-boxes
* "radiogroup": group of radio-buttons
* "checklistbox": listbox with checkboxes
* "spinedit": input for numbers, has min-value, max-value, increment
* "listview": list with columns, with column headers, value is index
* "checklistview": listview with checkboxes, value is check-flags
* "linklabel": label which activates URL on click
* "panel": rectangle with centered caption only (client area is entire rect)
* "group": rectangle with OS-themed border and caption on border (client area is decreased by this border)
* "colorpanel": panel, with N-pixels colored border, with colored background
* "image": picture, which shows picture-file
* "trackbar": horiz/vert bar with handler, has position
* "progressbar": horiz/vert bar, only shows position
* "progressbar_ex": like progressbar, with new styles
* "filter_listbox": input, which filters content of another "listbox" control
* "filter_listview": input, which filter content of another "listview" control
* "bevel": control which shows only border (at one side, or all 4 sides), w/o value/caption
* "tabs": TabControl: set of tabs, w/o pages attached to them
* "pages": PageControl: set of tabs, with pages attached to them (only one of pages is visible)
* "splitter": divider bar, which can be dragged by mouse. It finds "linked control", ie control with the same "parent" and "align", nearest to splitter. On mouse drag, splitter resizes this linked control. Recommended to place another control with "align": ALIGN_CLIENT, so splitter will resize two controls at once.

Notes:

* Controls "combo", "combo_ro", "listbox": value is 0-based index of selected item, or -1 if none is selected.
* Control "button_ex": to change advanced props, you must get handle via DLG_CTL_HANDLE, and pass it to button_proc().
* Control "treeview" don't have "items"/"value": to work with it, you must get handle of control via DLG_CTL_HANDLE, and pass it to tree_proc().
* Control "listbox_ex" don't have "items"/"value": to work with it, you must get handle of control via DLG_CTL_HANDLE, and pass it to listbox_proc().
* Control "toolbar" don't have "items"/"value": to work with it, you must get handle via DLG_CTL_HANDLE, and pass it to toolbar_proc().
* Control "statusbar" don't have "items"/"value": to work with it, you must get handle via DLG_CTL_HANDLE, and pass it to statusbar_proc().
* Control "editor" don't have "items"/"value": to work with it, you must get handle via DLG_CTL_HANDLE, and pass it to Editor() to make editor object.
* Control "paintbox" is empty area, plugin can paint on it. Get canvas_id via DLG_CTL_HANDLE, and use it in canvas_proc().
* Control property "name" is required for "filter_nnnnn" controls: must set name of listbox/listview, and name of its filter - to the same name with prefix "f_" (e.g. listbox name "mylist" with filter name "f_mylist").

==== Properties ====

Parameter "text" is "\n"-separated items, one item per control. Each item is chr(1)-separated props in the form "key=value". Possible props:

* "type": type of control; must be specified first
* "cap": caption
* "x", "y": position, left/top
* "w", "h": size, width/height
* "w_min", "w_max": Constraints for width, min/max value.
* "h_min", "h_max": Constraints for height, min/max value.
* "pos": position, str in the form "left,top,right,bottom". Some one-line controls ignore bottom and do auto size. If specified "x/y/w/h" together with "pos", then last mentioned prop has effect.
* "en": enabled state, bool
* "vis": visible state, bool
* "hint": hint string for mouse-over. Can be multiline, "\r"-separated.
* "texthint": text, shown with italic+pale font when value of control is empty. For "edit", "memo", "editor". Cannot be multi-line.
* "color": background color
* "autosize": control is auto-sized (by width and/or height, it's control-specific)
* "font_name": font name
* "font_size": font size
* "font_color": font color
* "font_style": font styles. String, each char can be: "b": bold, "i": italic, "u": underline, "s": strikeout.
* "name": optional name of control. It may be not unique for all controls.
* "act": active state, bool. For many controls (edit, check, radio, combo_ro, checkbutton, listbox'es, listview's, tabs), it means that control's value change fires events (for dlg_proc) or closes form (for dlg_custom).
* "ex0"..."ex9": advanced control-specific props. Described below.
* "props": deprecated; advanced control-specific props. Described below.
* "val": value of control. Described below.
* "items": list of items. Described below.

====Prop "items"====

Possible values of "items":

* combo, combo_ro, listbox, checkgroup, radiogroup, checklistbox, tabs: "\t"-separated lines
* listview, checklistview: "\t"-separated items.
** first item is column headers: title1+"="+size1 + "\r" + title2+"="+size2 + "\r" +...
** size1...sizeN can be with lead char to specify alignment of column: L (default), R, C
** other items are data: cell1+"\r"+cell2+"\r"+... (count of cells may be less than count of columns)
* image: full path of picture file (png/gif/jpg/bmp)

Action DLG_CTL_PROP_GET also gets key "items" (in the same format) for these controls: "listbox", "checklistbox", "listview", "checklistview".

====Prop "columns"====

* For "listview", "checklistview": "\t"-separated items, each item is "\r"-separated props of a column:
** caption (must be without "\t", "\r", "\n")
** width, as str
** (optional) minimal width, as str. 0 means "not used". Not supported on Windows.
** (optional) maximal width, as str. 0 means "not used". Not supported on Windows.
** (optional) alignment - one of "L", "R", "C"
** (optional) autosize - "0", "1"
** (optional) visible - "0", "1"

* For "radiogroup", it is number of vertical columns of radiobuttons.

Action DLG_CTL_PROP_GET also gets key "columns" in the same format.

Action DLG_CTL_PROP_SET, for "listview", allows both "items" (it sets columns) and "columns", and "columns" is applied last.

====Prop "val"====

* check: "0", "1" or "?" (grayed state)
* radio, checkbutton: "0", "1"
* edit, edit_pwd, spinedit, combo, filter_*: text
* memo: "\t"-separated lines, in which "\t" chars must be replaced to chr(3)
* combo_ro, listbox, radiogroup, listview: current index
* checkgroup: ","-separated checked states ("0", "1")
* checklistbox, checklistview: index + ";" + checked_states
* tabs, pages: index of active tab
* trackbar, progressbar: int position

====Prop "props"====

Deprecated. Tuple of advanced control-specific properties. See description of prop "ex". If some control supports 4 props, "ex0" to "ex3", then "props" must be 4-tuple for it. If some control supports only "ex0", then "props" must be one value, same as "ex0".

* For dlg_custom, "props" must be str with ","-separated items, and "0"/"1" for bool items.
* For dlg_proc, "props" must be simple type or tuple of simple types, e.g. (True, False, 2).

====Prop "ex"====

Props "ex0"..."ex9" are control-specific. They have different simple type (str, bool, int...).

* button:
** "ex0": bool: default for Enter key
* edit, memo:
** "ex0": bool: read-only
** "ex1": bool: font is monospaced
** "ex2": bool: show border
* spinedit:
** "ex0": int: min value
** "ex1": int: max value
** "ex2": int: increment
* label:
** "ex0": bool: right aligned
* linklabel:
** "ex0": str: URL. Should not have ",". Clicking on http:/mailto: URLs should work, result of clicking on other kinds depends on OS.
* listview:
** "ex0": bool: show grid lines
* radiogroup:
** "ex0": int: 0: arrange items horizontally then vertically (default); 1: opposite
* tabs:
** "ex0": bool: show tabs at bottom
* colorpanel:
** "ex0": int: border width (from 0)
** "ex1": int: color of fill
** "ex2": int: color of font
** "ex3": int: color of border
* filter_listview:
** "ex0": bool: filter works for all columns
* image:
** "ex0": bool: center picture
** "ex1": bool: stretch picture
** "ex2": bool: allow stretch in
** "ex3": bool: allow stretch out
** "ex4": bool: keep origin x, when big picture clipped
** "ex5": bool: keep origin y, when big picture clipped
* trackbar:
** "ex0": int: orientation (0: horz, 1: vert)
** "ex1": int: min value
** "ex2": int: max value
** "ex3": int: line size
** "ex4": int: page size
** "ex5": bool: reversed
** "ex6": int: tick marks position (0: bottom-right, 1: top-left, 2: both)
** "ex7": int: tick style (0: none, 1: auto, 2: manual)
* progressbar:
** "ex0": int: orientation (0: horz, 1: vert, 2: right-to-left, 3: top-down)
** "ex1": int: min value
** "ex2": int: max value
** "ex3": bool: smooth bar
** "ex4": int: step
** "ex5": int: style (0: normal, 1: marquee)
** "ex6": bool: show text (only for some OSes)
* progressbar_ex:
** "ex0": int: style (0: text only, 1: horz bar, 2: vert bar, 3: pie, 4: needle, 5: half-pie)
** "ex1": int: min value
** "ex2": int: max value
** "ex3": bool: show text
** "ex4": int: color of background
** "ex5": int: color of foreground
** "ex6": int: color of border
* bevel:
** "ex0": int: shape (0: sunken panel, 1: 4 separate lines - use it as border for group of controls, 2: top line, 3: bottom line, 4: left line, 5: right line, 6: no lines, empty space)
* splitter:
** "ex0": bool: paint border
** "ex1": bool: on mouse drag, use instant repainting (else splitter paints after mouse released)
** "ex2": bool: auto jump to edge, when size of linked control becomes < min size
** "ex3": int: mininal size of linked control (controlled by splitter)

====Result====

Dialog is closed by clicking any button or by changing of any control which has "act=1".

* If cancelled, gets None
* If get_dict=True, gets dict: {0: str_value_0, 1: str_value_1, ..., 'clicked': N, 'focused': N}
* If get_dict=False, gets 2-tuple: (clicked_index, state_text)
** "clicked_index": index of control which closed dialog (0-based).
** "state_text": "\n"-separated values of controls. Same count of items as in text, plus optional additional lines in the form "key=value". Line "focused=N" with index of last focused control (0-based) or -1.

====Notes====

* Property "type" must be first.
* Property "act" must be set after "val".

* Controls sizes differ on Win/Linux/OSX, picture shows controls (Linux/Win) auto-aligned, not in CudaText, only example app:

[[File:controls_autosizes.png]]

* So it's good to use common height for single-line controls, 30 pixels is ok for edit/button/check/radio, 36 for combobox.
* Control "tabs" height cannot auto-size, please make correct height for control (it is usually like big buttons).

===dlg_proc===

 dlg_proc(id_dialog, id_action, prop="", index=-1, index2=-1, name="")

Advanced work with dialogs (forms). More advanced than dlg_custom(), forms can show modal/nonmodal, controls can change value during form showing.

If an action needs control, you can use 2 ways:
* set param "name" to control's name (name is searched if not empty),
* set param "index" to control's index (you should use DLG_CTL_FIND to find it).

====Types====

Possible types of UI controls are described in dlg_custom, see [[#Types]]. Additional types only for dlg_proc:

* "button_ex": button, application-themed, works via button_proc()
* "editor": full featured editor, works via Editor class
* "listbox_ex": listbox, application-themed, works via listbox_proc()
* "paintbox": control which must be painted by plugin via canvas_proc()
* "statusbar": statusbar: panel with one horizontal row of cells, works via statusbar_proc()
* "toolbar": toolbar: panel which holds buttons with icons, works via toolbar_proc()
* "treeview": tree structure with nodes and nested nodes, works via tree_proc()

====Form properties====

* "cap": str: Caption of form.
* "x", "y": int: Position (screen coordinates), left/top.
* "w", "h": int: Size, width/height.
* "w_min", "w_max": int: Constraints for width, min/max value.
* "h_min", "h_max": int: Constraints for height, min/max value.
* "p": int: Handle of parent form, or 0 if no parent.
* "tag": str: Any string, set by plugin.
* "border": int: Sets border of form, DBORDER_nnn constants. Don't specify it together with deprecated "resize".
** DBORDER_NONE: No visible border, not resizable
** DBORDER_SIZE: Standard resizable border (on Windows: with Minimize/Maximize buttons)
** DBORDER_SINGLE: Single-line border, not resizable (on Windows: form has icon and Minimize button)
** DBORDER_DIALOG: Standard dialog box border, not resizable (on Windows: form has no icon nor Minimize button)
** DBORDER_TOOL: Like DBORDER_SINGLE but with a smaller caption
** DBORDER_TOOLSIZE: Like DBORDER_SIZE but with a smaller caption
* "topmost": bool: Makes form stay on top of other forms in CudaText.
* "vis": bool: Visible state.
* "color": int: Background color.
* "autosize": bool: Form resizes to minimal size, which shows all visible controls. Don't use it together with "resize".
* "keypreview": bool: If on, then key press calls on_key_down before passing key to focused control. Should be True if form needs to handle on_key_down.
* "p": int: Parent handle. Set this property to int handle of any windowed UI control or form, this control/form will be parent of form.
* "focused" (only for reading): index of currently focused control.
* (deprecated) "resize": bool: Border of form has "resizable" style.

====Form events====

These are also properties of forms.

* "on_resize": Called after form is resized.
* "on_close": Called after form is closed.
* "on_close_query": Called to ask plugin, is it allowed to close form (in any way: pressing Esc key, clicking X icon, pressing Alt+F4 or similar hotkey). Plugin must return bool, if True then form will be closed.

* "on_show": Called after form shows.
* "on_hide": Called after form hides.
* "on_act": Called when form is activated.
* "on_deact": Called when form is deactivated.
* "on_mouse_enter": Called when mouse cursor enters form area.
* "on_mouse_exit": Called when mouse cursor leaves form area.

* "on_key_down": Called when key is pressed in form (form should have "keypreview":True). If plugin returns False, key is blocked.
** param "id_ctl": int key code.
** param "data": key-state string: few chars, "c" for Ctrl, "a" for Alt, "s" for Shift, "m" for Meta.

* "on_key_up": Called when key is depressed (after on_key_down). If plugin returns False, depressing of key is blocked.

How to get nice key description in on_key_down, e.g. "Ctrl+Alt+Esc" from id_ctl=27 and data="ca":

<syntaxhighlight lang="python">
    str_key =\
      ('Meta+' if 'm' in data else '')+\
      ('Ctrl+' if 'c' in data else '')+\
      ('Alt+' if 'a' in data else '')+\
      ('Shift+' if 's' in data else '')+\
      app_proc(PROC_HOTKEY_INT_TO_STR, id_ctl)
</syntaxhighlight>

====Control properties====

* "name": str: Optional name of control, to find control later by name. May be not unique for controls.
* "cap": str: Caption.
* "x", "y": int: Position (coordinates relative to dialog), left/top.
* "w", "h": int: Size, width/height.
* "en": bool: Enabled state.
* "vis": bool: Visible state.
* "color": int: Color.
* "border": bool: Control has border.
* "font_name": str: Font name.
* "font_size": int: Font size.
* "font_color": int: Font color.
* "hint": str: Hint (tooltip) for mouse-over. Newlines must be "\r".
* "ex0"..."ex9": Advanced control-specific props. Described in dlg_custom.
* "props": Deprecated. Advanced control-specific props. Described in dlg_custom.
* "items": str: Usually tab-separated items. Described in dlg_custom.
* "val": str: Value of control. Described in dlg_custom.
* "tag": str: Any string, set by plugin.

* "focused": bool: Shows if control has focus.
* "tab_stop": bool: Allows tab-key to jump to this control.
* "tab_order": int: Tab-key jumps to controls using tab_orders. First activated is control with tab_order=0, next with =1, etc. If tab_orders not set, controls activated by creation order.

* "sp_l", "sp_r", "sp_t", "sp_b", "sp_a": int: Border spacing, ie padding of control's edge from anchored controls (or parent form). 5 props here: left, right, top, bottom, around. "Around" padding is added to padding of all 4 sides.

* "a_l", "a_r", "a_t", "a_b": 2-tuple (str_control_name, str_side): Anchors of control. See [[#Anchors]]. Value is 2-tuple, or None to disable anchor.
** Item-0: name of target control, or empty str to use control's parent (it is form by default).
** Item-1: side of target control, one of 3 values: "[" (left/top), "-" (center), "]" (right/bottom).

* "align": alignment of control:
** ALIGN_NONE: no alignment (props "x", "y", "w", "h" have meaning)
** ALIGN_CLIENT: stretched to entire parent area (props "x", "y", "w", "h" are ignored)
** ALIGN_LEFT: glued to the left side of parent (only prop "w" has meaning)
** ALIGN_RIGHT: glued to the right side of parent (only prop "w" has meaning)
** ALIGN_TOP: glued to the top of parent (only prop "h" has meaning)
** ALIGN_BOTTOM: glued to the bottom of parent (only prop "h" has meaning)

* "p": str: Name of control's parent, or empty to use the form. Coordinates x/y of control are relative to the current parent. If parent's position changes, control's position don't change. To place control on PageControl's page with index N, specify such parent name: pages_name+"."+str(N).

====Control events====

These are also properties of controls.

* "on_change": Called after "value" of control is changed.
* "on_click": Called after mouse click on control, for non-active controls, which don't change "value" by click. Param "data" is tuple (x, y) with control-related coordinates of click.
* "on_click_dbl": Called after mouse double-click on control. Param "data" is tuple (x, y) with control-related coordinates.
* "on_mouse_down": Called when mouse button pressed. Param "data" is dict: { "btn": int_button_code, "state": str_keyboard_state, "x": int, "y": int }. Button code: 0: left; 1: right; 2: middle. Keyboard state: value like in global event "on_key".
* "on_mouse_up": Called when mouse button depressed (released). Param "data": like in "on_mouse_down".
* "on_mouse_enter": Called when mouse cursor enters control area.
* "on_mouse_exit": Called when mouse cursor leaves control area.
* "on_focus_enter": Called when control gets focus. Not supported for controls (they don't have OS window handle): label, button, button_ex, panel, linklabel, colorpanel, bevel, image, progressbar_ex, paintbox, statusbar.
* "on_focus_exit": Called when control looses focus. Supported for the same controls as "on_focus_enter". 
* "on_menu": Called before showing context menu, after right click or ContextMenu hotkey. Param "data": like in "on_mouse_down". Method can return False to disable default menu (if any).

Events for control "listview"/"checklistview":

* "on_click_header": Called when user clicks on column header. Param "data": int column index.
* "on_select": Called after selection is changed. Param "data" is tuple: (int_item_index, bool_item_selected).

Events for control "listbox_ex":

* "on_draw_item": Called if listbox is owner-drawn. Param "data" is dict: { "canvas": canvas_id, "index": int_item_index, "rect": item_rectangle_4_tuple }.

Events for control "treeview":

* "on_fold", "on_unfold": Called before treeview node is folded/unfolded. Param "data" is int handle of treeview node.
* "on_select": Called after selection is changed.

Events for control "editor":

* "on_change": Called after text is changed.
* "on_caret": Called after caret position and/or selection is changed.
* "on_scroll": Called after editor is scrolled.
* "on_key_down": Called when user presses a key. Param "data" is tuple (int_key_code, str_key_state). Method can return False to disable default processing.
* "on_key_up": Called when user depresses a key. Param "data" is tuple (int_key_code, str_key_state). Method can return False to disable default processing.
* "on_click_gutter": Called on mouse click on gutter area. Param "data" is dict: {"state": str_key_state, "line": int_line_index, "band": int_gutterband_index}.
* "on_click_gap": Called on mouse click on inter-line gap. Param "data" is dict: {"state": str_key_state, "line": int, "tag": int, "gap_w": int, "gap_h": int, "x": int, "y": int}.
* "on_paste": Called before doing one of Paste commands. Param "data" is dict: {"keep_caret": bool, "sel_then": bool}. Method can return False to disable default operation.

====Callbacks====

Values of events are callbacks, must be in one of these forms: [[#Callback_param]].

Callbacks for dlg_proc must be declared as:

<syntaxhighlight lang="python">
#function
def my(id_dlg, id_ctl, data='', info=''):
  pass
#method
class Command:
  def my(self, id_dlg, id_ctl, data='', info=''):
    pass
</syntaxhighlight>

Parameters:

* "id_dlg": Int handle of form.
* "id_ctl": Int index of control (usually; in on_key_down it has different meaning).
* "data": Value, specific to event.
* "info": Value from extended form of callback string.

====Actions====

Param prop: it can be of any simple type (str, int, bool), also tuple/list (of any simple type), also dict (keys: str, values: simple type or tuple/list). Most used is dict. Example: prop={"cap": "...", "x": 10, "y": 10, "w": 600, "en": False}.

Param id_dialog: int, form handle. Ignored only for DLG_CREATE (pass 0).

Possible values of "id_action":

* DLG_CREATE: Creates new empty form, gets form "handle". You must pass this handle (int) to next calls of dlg_proc().
* DLG_HIDE: Hides form.
* DLG_FREE: Hides and deletes form.
* DLG_SHOW_MODAL: Shows form in modal mode. Waits for form to hide, then returns.
* DLG_SHOW_NONMODAL: Shows form in non-modal mode. Returns immediately.
* DLG_FOCUS: Focuses form (in non-modal mode).
* DLG_SCALE: Scales form, with all controls, for the current OS high-DPI value. E.g. of OS scale is 150%, all will be scaled by 1.5.

* DLG_PROP_GET: Gets form props, as dict. See example plugin, which props are returned.
* DLG_PROP_SET: Sets form props, from dict. Param "prop" is dict. Only props mentioned in "prop" are applied, other props don't change.

* DLG_DOCK: Docks (inserts) form into another form. Param "index" is handle of another form, and 0 means main CudaText form. Param "prop" can be: "L", "R", "T", "B" for sides left/right/top/bottom (default is bottom).
* DLG_UNDOCK: Undocks form from it's current parent form.

* DLG_CTL_COUNT: Gets count of controls on form.
* DLG_CTL_ADD: Adds new control to form, gets its index, or None if cannot add. Param "prop" is type of control. See description in dlg_custom.
* DLG_CTL_PROP_GET: Gets control props, as dict. Control must be specified by name or index.
* DLG_CTL_PROP_SET: Sets control props.  Control must be specified by name or index. Param "prop" is dict with props. Only props mentioned in "prop" are applied, other props don't change. To "reset" some props, you must mention them with some value.
* DLG_CTL_FOCUS: Focuses control.  Control must be specified by name or index.
* DLG_CTL_DELETE: Deletes control.  Control must be specified by name or index. Controls are stored in list, so after a control deleted, indexes of next controls shift by -1. So don't use fixed indexes if you delete some, use DLG_CTL_FIND.
* DLG_CTL_DELETE_ALL: Deletes all controls.
* DLG_CTL_FIND: Gets index of control by name, or -1 if cannot find. Param "prop" is name.
* DLG_CTL_HANDLE: Gets int "handle" of control on a form. Control must be specified by name or index. This handle is currently useful for types:
** type "button_ex": pass handle to button_proc()
** type "editor": pass handle to Editor() constructor
** type "listbox_ex": pass handle to listbox_proc()
** type "paintbox": pass handle to canvas_proc()
** type "statusbar": pass handle to statusbar_proc()
** type "treeview": pass handle to tree_proc()
** type "toolbar": pass handle to toolbar_proc()

* DLG_COORD_LOCAL_TO_SCREEN: Converts x/y coordinates from form-related, to screen-related. Param "index" is x, "index2" is y. Gets tuple (x,y).
* DLG_COORD_SCREEN_TO_LOCAL: Converts x/y coordinates from screen-related, to form-related. Param "index" is x, "index2" is y. Gets tuple (x,y).

====Anchors====

Anchor is attaching of control's side to another control, or to the parent form, so control is auto positioned, initially and on form resize. Lazarus IDE has such Anchor Editor dialog:

[[Image:Anchor_Editor_en.png]]

In this dialog you see, that all 4 sides of control attach to one of 3 sides of another control (or parent form).

* Anchors override absolute positions, e.g. anchor of left side overrides prop "x".
* Anchoring to invisible control is allowed.
* Anchoring circles (A to B to C to A) is not allowed, but should not give errors.

To change anchors of control, set its properties: a_l, a_r, a_t, a_b.
Initially left/top anchors are set (to the parent form).

Side value "[" aligns control to left/top side of target:

          +--------+
          | target |
          +--------+

          +--------------+
          |   control    |
          +--------------+

Side value "]" aligns control to right/bottom side of target:

           +--------+
           | target |
           +--------+

     +--------------+
     |   control    |
     +--------------+

Side value "-" centers control relative to target:

           +--------+
           | target |
           +--------+

        +--------------+
        |   control    |
        +--------------+

Example: to attach "colorpanel" to the right side of form, clear left anchor (set to None), and add right/bottom anchors. This also sets spacing-aroung (padding) to 6 pixels.

<syntaxhighlight lang="python">
  #attach colorpanel to the right
  dlg_proc(id_form, DLG_CTL_PROP_SET, index=n, prop=
      { 'a_l': None, 'a_r': ('', ']'), 'a_b': ('', ']'), 'sp_a': 6  } )
</syntaxhighlight>

====Example====

Detailed demo plugin exists, it shows many dlg_proc actions, shows modal/nonmodal forms, uses callbacks, moves control by button click, moves control on form resize. It is in the CudaText repo with name "cuda_testing_dlg_proc".

===dlg_commands===

 dlg_commands(options, title="")

Show commands dialog, which is customizable version of Commands (F1) dialog in CudaText.

Param "options" should be 0 or sum of int flags:

* COMMANDS_USUAL: Show usual commands, which have int codes. Function gets "c:"+str(int_command) for them.
* COMMANDS_PLUGINS: Show plugins commands. Function gets "p:"+callback_string for them.
* COMMANDS_LEXERS: Show lexers pseudo-commands. Function gets "l:"+lexer_name for them.
* COMMANDS_CONFIG: Allow to call Configure Hotkeys dialog by F9 key.
* COMMANDS_CENTERED: Set dialog position to the center of desktop. Otherwise, position depends on CudaText option.

Gets string if command selected, or None if cancelled.

===file_open===

 file_open(filename, group=-1, options="")
 file_open((filename1, filename2), group=-1, options="")

Opens editor tab with given filename. If filename already opened, activates its tab. Pass empty string to open untitled tab.

First parameter can be 2-tuple (or 2-list) of string, to open two files in a single tab, in a splitted view. In this case, second filename won't be handled specially for zip file, picture file, binary file etc.

Gets bool. True, if first filename is empty. Otherwise, gets True if first filename exists, and second filename is empty or exists.
For zip file (only first filename is checked for it), gets True only if zip file contains valid CudaText add-on, and it was installed.

* Param "group": index of tab-group (0-based), default means "current group". If you pass index of currently hidden group, group won't show, you need to call editor command to show it, see [[#cmd]].
* Param "options": string:
** If it has "/preview", then file opens in a "temporary preview" tab, with italic caption. Param "group" is ignored then, used 1st group.
** If it has "/nohistory", file's saved history (caret, scroll pos, etc) won't be used.
** If it has "/noevent", then "on_open_pre" event won't fire.
** If it has "/silent", then zipped add-on will install w/o prompt and report.
** If it has "/passive", then tab will not activate, it will be passive tab.
** If it has "/nonear", then app option "ui_tab_new_near_current" will be ignored, tab will append to end.
** If it has "/nozip", then .zip files will not be handled specially.
** If it has "/nopictures", then picture files will not be handled specially.
** If it has "/view-text', then file will open in internal viewer, text (variable width) mode.
** If it has "/view-binary', then file will open in internal viewer, binary (fixed width) mode.
** If it has "/view-hex', then file will open in internal viewer, hex mode.
** If it has "/view-unicode', then file will open in internal viewer, unicode (variable width) mode.
** If it has "/nontext-view-text", then in the case of non-text file, file will open in internal viewer, text (variable width) mode.
** If it has "/nontext-view-binary", then in the case of non-text file, file will open in internal viewer, binary (fixed width) mode.
** If it has "/nontext-view-hex", then in the case of non-text file, file will open in internal viewer, hex mode.
** If it has "/nontext-view-unicode", then in the case of non-text file, file will open in internal viewer, unicode mode.
** If it has "/nontext-cancel", then in the case of non-text file, function will fail and return False.

Note: "ed" is always the current editor, after file_open() current editor changes, and "ed" is the new cur editor.

Example opens untitled tab, and writes multi-line text to it:
<syntaxhighlight lang="python">
  file_open('')
  ed.set_text_all(text)
</syntaxhighlight>

===ed_handles===

 ed_handles()

Gets range object: it contains int handles of all editor tabs. Pass each handle to Editor() to make editor object from handle.

Example code, which shows filenames of all tabs:

<syntaxhighlight lang="python">
    #show all file names in console
    for h in ed_handles():
        e = Editor(h)
        print(e.get_filename())
</syntaxhighlight>

===ed_group===

 ed_group(index)

Gets Editor object for active editor in tab-group with given group-index. Gets None for incorrect index, or if no tabs in this group.

Index possible values: 0..5 (first 6 groups) and 6..8 (3 floating groups).

===ini_read/ini_write===

 ini_read(filename, section, key, value)
 ini_write(filename, section, key, value)

Reads/writes single string from/to .ini file. Params:

* "filename": str: Path of file. Can be without path, this means that path of "settings" dir is used.
* "section": str: Section of ini file.
* "key": str: Key in section.
* "value": str:
** on read: default value which is returned if no such filename/section/key was found.
** on write: value to write.

On read: gets string value. On write: gets None.

===ini_proc===

 ini_proc(id, filename, section="", key="")

Performs action on .ini file. Filename can be without path, this means that path of "settings" dir is used.

Possible values of "id":

* INI_GET_SECTIONS: Gets list of sections. Params "section", "key" ignored.
* INI_GET_KEYS: Gets list of keys in given section. Param "key" ignored.
* INI_DELETE_KEY: Deletes given key in given section.
* INI_DELETE_SECTION: Deletes given section with all its keys. Param "key" ignored.

===lexer_proc===

 lexer_proc(id, value)

Perform some lexer-related action.

Possible values of "id":

* LEXER_GET_LEXERS: Gets list of lexers. Param "value" must be bool: allow to include also hidden lexers (not visible in the lexers menu).
* LEXER_GET_PROP: For lexer name (param "value"), gets its properties as dict. For incorrect lexer name, gets None. Keys of dict:
** "en": bool: lexer is visible in the lexers menu.
** "typ": list of str: list of file-types (they detect lexer when file loads; "ext" is simple extension, "ext1.ext2" is double extension, "/fullname" is name w/o path).
** "st": list of str: list of all styles.
** "st_c": list of str: list of styles of syntax comments (e.g. used by Spell Checker).
** "st_s": list of str: list of styles of syntax strings (e.g. used by Spell Checker).
** "sub": list of str: list of sub-lexers (some items can be empty if lexer setup broken).
** "c_line": str or None: line comment (until end-of-line).
** "c_str": 2-tuple or None: stream comment (for any range).
** "c_lined": 2-tuple or None: comment for full lines.

* LEXER_DETECT: Detects lexer name by file name (param "value" is file name). Gets None if cannot detect. Function sees file extension, or even filename before extension (e.g. "/path/makefile.gcc" gives "Makefile").
* LEXER_REREAD_LIB: Re-reads lexer library from disk, updates lexer menu. Make sure that plugins' dialogs don't use editor with lexer, which may crash.

===tree_proc===

 tree_proc(id_tree, id_action, id_item=0, index=0, text="", image_index=-1)

Perform action on treeview UI-control.

* Param id_tree is int handle of treeview.
* Param id_item is int handle of tree-item. Can be 0 for invisible root-item:
** can clear entire tree using root-item
** can enumerate root level using root-item.

Possible values of "id_action":

* TREE_ITEM_ENUM: Enumerates subitems on given item. Param id_item. Gets list of 2-tuples: (int_handle, str_caption), or None.
* TREE_ITEM_ADD: Adds subitem as item's child. Param id_item. Param index: at which subitem index to insert (0-based), or -1 to append. Param text: caption of item. Param image_index: index in tree's icon list or -1 to not show icon. Gets int handle of subitem.
* TREE_ITEM_DELETE: Deletes item (with all subitems). Param id_item.
* TREE_ITEM_SET_TEXT: Sets item's text. Params: id_item, text.
* TREE_ITEM_SET_ICON: Sets item's icon. Params: id_item, image_index.

* TREE_ITEM_SELECT: Selects item.
* TREE_ITEM_SHOW: Makes item visible, ie scrolls control to this item.
* TREE_ITEM_GET_SELECTED: Gets int handle of selected item (id_item ignored). Gets None if none selected.

* TREE_ITEM_GET_PROPS: Gets props of item, as dict. Dict keys are:
** "text": str: caption of item
** "icon": int: index of icon in tree's imagelist object, or -1 for none
** "level": int: how deep this item is nested (how many parents this item has)
** "parent": int: id of parent item, or 0 if no parent
** "folded": bool: is this item folded (item itself, not parents)
** "selected": bool: is this item selected
** "sub_items": bool: item has sub-items
** "index": int: index of item, relative to its branch
** "index_abs": int: absolute index of item, relative to root

* TREE_ITEM_FOLD: Folds item w/o subitems.
* TREE_ITEM_FOLD_DEEP: Folds item with subitems. Root-item allowed too.
* TREE_ITEM_FOLD_LEVEL: Folds all items (id_item ignored) from level with specified index, 1 or bigger. (This is what CudaText commands "fold level N" do for code-tree).
* TREE_ITEM_UNFOLD: Unfolds item w/o subitems.
* TREE_ITEM_UNFOLD_DEEP: Unfolds item with subitems. Root-item allowed too.
* TREE_GET_IMAGELIST: Gets int handle of image-list object.
* TREE_PROP_SHOW_ROOT: This allows to hide lines for invisible root-item. If hidden, tree (folded) looks like listbox. Param text: "0"/"1" to hide/show.
* TREE_LOCK: Disables repainting of control.
* TREE_UNLOCK: Enables repainting of control.
* TREE_THEME: Applies current color theme to control.

* TREE_ITEM_GET_RANGE: Should be used only for code-tree. Gets range, stored in tree-item, as 4-tuple (start_x, start_y, end_x, end_y). If range is not set, gets (-1,-1,-1,-1).
* TREE_ITEM_SET_RANGE: Should be used only for code-tree. Sets range for tree-item. Param "text" must be 4-tuple of int (start_x, start_y, end_x, end_y).

===listbox_proc===

 listbox_proc(id_listbox, id_action, index=0, text="", tag=0)

Perform action on listbox UI-control.

* Param id_listbox: int handle of listbox.
* Param index: index of item (0-base).

Possible values of "id_action":

* LISTBOX_GET_COUNT: Gets number if items.
* LISTBOX_ADD: Adds item (str) with associated tag (int). Param "index": at which index to add, -1 to append.
* LISTBOX_DELETE: Deletes item with given index.
* LISTBOX_DELETE_ALL: Deletes all items.
* LISTBOX_GET_ITEM: Gets item with given index as 2-tuple (text, tag). Gets None if index incorrect.
* LISTBOX_SET_ITEM: Sets item with given index, to given text and tag.
* LISTBOX_GET_ITEM_H: Gets height of items in pixels.
* LISTBOX_SET_ITEM_H: Sets height of items in pixels. Param "index": size.
* LISTBOX_GET_SEL: Gets selected index. -1 for none.
* LISTBOX_SET_SEL: Sets selected index. -1 for none.
* LISTBOX_GET_TOP: Gets index of top visible item.
* LISTBOX_SET_TOP: Sets index of top visible item.
* LISTBOX_GET_DRAWN: Gets bool: listbox is owner-drawn, ie it don't paint itself, but plugin must paint it via event on_draw_item.
* LISTBOX_SET_DRAWN: Sets owner-drawn state. Param "index" should be 0 or 1 (off/on).

Listbox can have columns. It works only if listbox is not owner-drawn, and column sizes were set via LISTBOX_SET_COLUMNS. You must add separator-chars inside items to split items into columns. Column sizes are passed as list of int. Each list item can be:
* value>0: Column width in pixels.
* value<0: Column width in percents of listbox width.
* value=0: Column is auto-stretched to fill the entire width. Several auto-stretched columns are allowed.

Actions for columns:

* LISTBOX_GET_COLUMN_SEP: Gets column separator char.
* LISTBOX_SET_COLUMN_SEP: Sets column separator char. Param "text" must be single-char string.
* LISTBOX_GET_COLUMNS: Gets list of column sizes.
* LISTBOX_SET_COLUMNS: Sets list of column sizes. Param "text" must be list of int.

===canvas_proc===

 canvas_proc(id_canvas, id_action,
   text="", color=-1, size=-1,
   x=-1, y=-1, x2=-1, y2=-1,
   style=-1, p1=-1, p2=-1)

Performs action on canvas (drawing surface of some GUI control).
Id_canvas is handle of canvas of some GUI control. Special value 0 means testing empty panel, it appears at the top of app, when used.

Possible values of "id_action":

* CANVAS_SET_FONT: Sets props of font. Params:
** "text": font name
** "color"
** "size"
** "style": 0 for normal, or sum of values FONT_B (bold), FONT_I (italic), FONT_U (underline), FONT_S (strikeout)

* CANVAS_SET_PEN: Sets props of pen. Params:
** "color"
** "size"
** "style": one of PEN_STYLE_nnnn
** "p1": end caps style - one of PEN_CAPS_nnnn
** "p2": line joining style - one of PEN_JOIN_nnnn

* CANVAS_SET_BRUSH: Sets props of brush. Params:
** "color"
** "style": one of BRUSH_nnnn. Usually used: BRUSH_SOLID (filled background), BRUSH_CLEAR (transparent background).

* CANVAS_SET_ANTIALIAS: Sets anti-aliasing mode of canvas. Params: style - ANTIALIAS_NONE, _ON, _OFF.
* CANVAS_GET_TEXT_SIZE: Gets size of text on canvas, as 2-tuple (size_x, size_y). Uses font. Params: text.
* CANVAS_TEXT: Paints text at given coords. Uses font and brush. Params: text, x, y.
* CANVAS_LINE: Paints line at given coords. Uses pen. Params: x, y, x2, y2.
* CANVAS_PIXEL: Paints one pixel at given coords. Params: x, y, color.
* CANVAS_RECT: Paints rectangle. Uses pen and brush. Params: x, y, x2, y2.
* CANVAS_RECT_FRAME: Paints rectangle. Uses only pen. Params: x, y, x2, y2.
* CANVAS_RECT_FILL: Paints rectangle. Uses only brush. Params: x, y, x2, y2.
* CANVAS_RECT_ROUND: Paints rounded rectangle. Uses pen and brush. Params: x, y, x2, y2, style - radius of corners.
* CANVAS_ELLIPSE: Paints ellipse or circle. Uses pen and brush. Params: x, y, x2, y2.
* CANVAS_POLYGON: Paints polygon from any number of points (>2). Uses pen and brush. Params: text - comma separated list of (x,y) coords. Example: "10,10,200,50,10,100" - 3 points.
* CANVAS_SET_TESTPANEL: Sets height of testing panel at the top. Params: size. If it's "too small", panel hides; for big size, size is limited.

=== timer_proc ===

 timer_proc(id, callback, interval, tag="")

Perform action on timers. Many different timers allowed, they work at the same time, each uniq callback - makes new timer with its own interval. To stop some timer, you must specify same callback as on start.

* "callback": Callback which is called on timer tick, see below.
* "interval": Timer delay in msec, 150 or bigger. Specify it only on starting (ignored on stopping).
* "tag": Some string, if not empty, it will be parameter to callback. If empty, callback is called without additional params.

Possible values of "id":

* TIMER_START - Create and start timer, for infinite ticks. If timer for such callback is already created, then it's restated.
* TIMER_START_ONE - Create and start timer, for single tick. If timer for such callback is already created, then it's restated.
* TIMER_STOP - Stop timer (timer must be created before).
* TIMER_DELETE - Stop timer, and delete it from list of timers. Usually don't use it, use only to save memory if created lot of timers.

Result is True if params ok; False if params not ok (callback str incorrect, interval incorrect, not created callback on stopping); or None (for unknown id).

====Callbacks====

Callback param must be in one of these forms: [[#Callback_param]].

Callbacks in timer_proc must be declared as:

<syntaxhighlight lang="python">
#function
def my(tag='', info=''):
  pass
#method
class Command:
  def my(self, tag='', info=''):
    pass
</syntaxhighlight>

===menu_proc===

 menu_proc(id_menu, id_action, command="", caption="", index=-1, hotkey="", tag="")

Perform action on menu items.

====Menu id====

Value of "id_menu" can be:

* number, str(number): all menu items can be specified by unique int value
* "top": top menu
* "top-file": top menu "File" submenu
* "top-edit": top menu "Edit" submenu
* "top-sel": top menu "Selection" submenu
* "top-sr": top menu "Search" submenu
* "top-view": top menu "View" submenu
* "top-op": top menu "Options" submenu
* "top-help": top menu "Help" submenu
* "text": editor context menu
* "tab": tab header context menu
* "toolmenu:"+name: dropdown submenu of toolbar button

====Command for new items====

Value of "command" parameter for MENU_ADD can be:

* int_command or str(int_command) - int command code, from module cudatext_cmd (pass 0 if item does nothing)
* callback in one of these forms: [[#Callback_param]].
* (deprecated callback form) callback in the form "module,method" or "module,method,param" (param can be of any primitive type).

* to create standard special sub-menus, special values:
** "_recents": Recent-files submenu
** "_enc": Encodings submenu (has subitems "reload as", "convert to")
** "_lexers": Lexers submenu
** "_plugins": Plugins submenu
** "_oplugins": Settings-plugins submenu

* empty string, if item will be used as submenu (item is a submenu, if any subitems are added to it)

====Item props as dict====

Some actions get dict for menu items. Dict keys:

* "id": menu_id, int
* "cap": caption, str (for separator items it is "-")
* "cmd": command code (e.g. from module cudatext_cmd), int
* "hint": callback (used if "cmd" value <=0), str
* "hotkey": hotkey, str
* "command": combined command description: int value of "cmd" (if code>0), or str value of "hint" (otherwise)
* "tag": plugin-defined tag, str
* "en": enabled state, bool
* "vis": visible state, bool
* "checked": checked state, bool
* "radio": radio-item state, bool (it means round checkmark in checked state)

====Actions====

Possible values of "id_action":

* MENU_CLEAR: Removes all sub-items from menu item.
* MENU_ENUM: Enumerates sub-items of the menu item. Gets list of dict, or None (for incorrect menu_id).
* MENU_GET_PROP: Gets props of menu item, as dict.

* MENU_ADD: Adds sub-item to menu item. Gets string, menu_id for newly added sub-item. Params:
** "id_menu": Item in which you add sub-item.
** "caption": Caption of item, or "-" for menu separator.
** "index": Index (0-based) at which to insert sub-item. Default: append item to end.
** "command": Values are described above.
** "hotkey": String of hotkey (e.g. "Ctrl+Shift+A"). Hotkey combos are not allowed. It overrides hotkey, which is auto assigned from command code.
** "tag": Any string stored in menu item.

* MENU_REMOVE: Deletes menu item. Note: don't remove items, which are auto-updated by CudaText, because you'll get Access Violation on showing menu containing these items. E.g. some items in the tab context menu are auto-updated.
* MENU_CREATE: Creates new popup-menu, independent from CudaText menus. It can be filled like other menus, then shown via MENU_SHOW.
* MENU_SHOW: Shows given popup-menu. Only menu created with MENU_CREATE should be specified here. Param "command" must be tuple (x,y) or string "x,y" with screen-related coordinates, if empty - menu shows at mouse cursor.

* MENU_SET_CAPTION: Changes caption of menu item. Param "command" must be str value.
* MENU_SET_VISIBLE: Changes visible state of menu item. Param "command" must be bool value.
* MENU_SET_ENABLED: Changes enabled state of menu item. Param "command" must be bool value.
* MENU_SET_HOTKEY: Changes hotkey of menu item. Param "command" must be str value, e.g. "Ctrl+Alt+F1".
* MENU_SET_CHECKED: Changes checked state of menu item. When item is checked, it shows a checkmark. Param "command" must be bool value.
* MENU_SET_RADIOITEM: Changes radio kind of menu item. When item has radio kind, its checkmark is round (in checked state). Param "command" must be bool value.
* MENU_SET_IMAGELIST: Changes image-list object of menu, which contains menu item. Param "command" must be image-list handle.
* MENU_SET_IMAGEINDEX: Changes icon index of menu item (index in image-list). Param "index" must be icon index.

====Example====

Example adds item "Misc" to the main menu, and sub-items: "About", separator, "Rename file" (from CudaExt plugin):

<syntaxhighlight lang="python">
  menuid = menu_proc('top', MENU_ADD, caption='Misc')
  n = menu_proc(menuid, MENU_ADD, command=2700, caption='About')
  n = menu_proc(menuid, MENU_ADD, caption='-')
  n = menu_proc(menuid, MENU_ADD, command='cuda_ext.rename_file', caption='Rename file')
</syntaxhighlight>

Example creates popup-menu with one item and shows it at (x=100, y=100):

<syntaxhighlight lang="python">
  h = menu_proc(0, MENU_CREATE)
  menu_proc(h, MENU_ADD, command=2700, caption='About...')
  menu_proc(h, MENU_SHOW, command=(100,100) )
</syntaxhighlight>

===toolbar_proc===

 toolbar_proc(id_toolbar, id_action, text="", text2="", command=0, index=-1, index2=-1)

Perform action on toolbar UI control.

Param "id_toolbar": int handle of toolbar. Can be "top" for main app toolbar. Function gets None, if id_toolbar not correct.

Param "id_action" possible values:

* TOOLBAR_GET_COUNT: Gets number of buttons in toolbar.
* TOOLBAR_GET_IMAGELIST: Gets int handle of image-list object.
* TOOLBAR_GET_BUTTON_HANDLE: Gets int handle of button to use in button_proc(), or None if index not correct. Param "index": button index.
* TOOLBAR_GET_BUTTON_HANDLES: Gets list of handles of all buttons.
* TOOLBAR_DELETE_ALL: Deletes all buttons.
* TOOLBAR_DELETE_BUTTON: Deletes one button. Param "index": button index.
* TOOLBAR_ADD_ITEM: Adds one button, usual. Param "index": button index at which to insert, -1 to append. You need to get handle of this button, and customize button via button_proc().
* TOOLBAR_ADD_MENU: Adds one button, with submenu. Param "index": button index at which to insert, -1 to append.
* TOOLBAR_UPDATE: Updates buttons positions and sizes (for current size of image-list, current captions etc).
* TOOLBAR_GET_VERTICAL: Gets vertical state of toolbar.
* TOOLBAR_SET_VERTICAL: Sets vertical state of toolbar. Param "index": bool value.
* TOOLBAR_GET_WRAP: Gets wrappable state of toolbar.
* TOOLBAR_SET_WRAP: Sets wrappable state of toolbar (implemented for horizontal toolbar only). Param "index": bool value.
* TOOLBAR_THEME: Applies current UI theme to toolbar.

====Example====

Example adds button to show About dialog:

 toolbar_proc('top', TOOLBAR_ADD_BUTTON, text='About', text2='about program...', index2=4, command=2700)

Example adds button with dropdown submenu, which has 2 items:

 toolbar_proc('top', TOOLBAR_ADD_BUTTON, text='Dropdown', index2=4, command="toolmenu:drop")
 menu_proc('toolmenu:drop', MENU_CLEAR)
 menu_proc('toolmenu:drop', MENU_ADD, caption='About...', command=2700)
 menu_proc('toolmenu:drop', MENU_ADD, caption='Edit plugin...', command="cuda_addonman,do_edit")

===statusbar_proc===

 statusbar_proc(id_statusbar, id_action, index=-1, tag=0, value="")

Perform action on statusbar UI control.

* Param "id_statusbar": handle of control. Can be "main" for main program statusbar.
* Param "index": index of cell (0-based), if action needs it.
* Param "tag": int tag of cell. Tag value, if not 0, overrides "index" param. It's needed to address a cell without knowing its index, only by tag. CudaText addresses standard cells by tag in the range 1..20.

Param "id_action" can be:

* STATUSBAR_GET_COUNT: Gets int number of cells.
* STATUSBAR_DELETE_ALL: Deletes all cells.
* STATUSBAR_DELETE_CELL: Deletes one cell (by "index" or "tag").

* STATUSBAR_ADD_CELL: Adds one cell. Param "index": -1: cell will be appended; >=0: cell will be inserted at given index. Param "tag" has special meaning: it is tag value of a new cell. Gets index of new cell, or None if cannot add (e.g. "tag" is busy).
* STATUSBAR_FIND_CELL: Gets index if cell from tag, or None. Param "value": int tag. Params "index", "tag" ignored.

* STATUSBAR_GET_IMAGELIST: Gets handle of image-list object, attached to statusbar, or 0 for none.
* STATUSBAR_SET_IMAGELIST: Sets handle if image-list object. Param "value": handle.

* STATUSBAR_GET_COLOR_BACK: Gets color of background.
* STATUSBAR_GET_COLOR_FONT: Gets color of font.
* STATUSBAR_GET_COLOR_BORDER_TOP: Gets color of border-top.
* STATUSBAR_GET_COLOR_BORDER_L: Gets color of border-left.
* STATUSBAR_GET_COLOR_BORDER_R: Gets color of border-right.
* STATUSBAR_GET_COLOR_BORDER_U: Gets color of border-up.
* STATUSBAR_GET_COLOR_BORDER_D: Gets color of border-down.

* STATUSBAR_SET_COLOR_BACK: Sets color of background. Param "value": int color.
* STATUSBAR_SET_COLOR_FONT: Sets color of font.
* STATUSBAR_SET_COLOR_BORDER_TOP: Sets color of border-top.
* STATUSBAR_SET_COLOR_BORDER_L: Sets color of border-left.
* STATUSBAR_SET_COLOR_BORDER_R: Sets color of border-right.
* STATUSBAR_SET_COLOR_BORDER_U: Sets color of border-up.
* STATUSBAR_SET_COLOR_BORDER_D: Sets color of border-down.

* STATUSBAR_GET_CELL_SIZE: Gets width of cell.
* STATUSBAR_GET_CELL_AUTOSIZE: Gets auto-size of cell, bool. Auto-size: adjust width of cell to its icon+text.
* STATUSBAR_GET_CELL_AUTOSTRETCH: Gets auto-stretch of cell, bool. Auto-stretch: stretch cell to fill entire statusbar width.
* STATUSBAR_GET_CELL_ALIGN: Gets alignment of cell. One of str values: "L" (left), "C" (center), "R" (right).
* STATUSBAR_GET_CELL_TEXT: Gets text of cell.
* STATUSBAR_GET_CELL_HINT: Gets hint of cell.
* STATUSBAR_GET_CELL_IMAGEINDEX: Gets icon index (inside image-list) of cell, -1 for none.
* STATUSBAR_GET_CELL_COLOR_FONT: Gets font color of cell, COLOR_NONE if not set.
* STATUSBAR_GET_CELL_COLOR_BACK: Gets background color of cell, COLOR_NONE if not set.
* STATUSBAR_GET_CELL_TAG: Gets int tag of cell.

* STATUSBAR_SET_CELL_SIZE: Sets width of cell. Param "value": int.
* STATUSBAR_SET_CELL_AUTOSIZE: Sets auto-size of cell. Param "value": bool.
* STATUSBAR_SET_CELL_AUTOSTRETCH: Sets auto-stretch of cell. Param "value": bool.
* STATUSBAR_SET_CELL_ALIGN: Sets alignment of cell. Param "value": str constant: "L", "C", "R".
* STATUSBAR_SET_CELL_TEXT: Sets text of cell. Param "value": str.
* STATUSBAR_SET_CELL_HINT: Sets hint of cell. Param "value": str.
* STATUSBAR_SET_CELL_IMAGEINDEX: Sets icon index (inside image-list) of cell, -1 for none. Param "value": int.
* STATUSBAR_SET_CELL_COLOR_FONT: Sets font color of cell. Param "value": int color or COLOR_NONE.
* STATUSBAR_SET_CELL_COLOR_BACK: Sets background color of cell. Param "value": int color or COLOR_NONE.
* STATUSBAR_SET_CELL_TAG: Sets tag of cell. Param "value": int.

Notes:

* If cell text not empty, alignment applies only for text, icon is on the left. If text empty, alignment applies for icon.

===imagelist_proc===

 imagelist_proc(id_list, id_action, value="")

Perform action on image-list object.

Param "id_list" is int handle of image-list. It is required for all actions, except IMAGELIST_CREATE, where it should be 0.

Possible values of "id_action":

* IMAGELIST_CREATE: Creates new image-list object with default icon size 16x16. Gets int handle of this image-list. Param "value" must be int handle of owner form of object.
** If it is form handle from dlg_proc, object will be deleted after deletion of this form.
** If it is 0, main application form is used as owner, and object will be persistent.

* IMAGELIST_COUNT: Gets int number of icons in image-list.
* IMAGELIST_GET_SIZE: Gets current icon size as 2-tuple (width, height).
* IMAGELIST_SET_SIZE: Sets new icon size, and clears image-list. Param "value" must be 2-tuple of int (width, height). Gets new icon size (corrected by minimal value) as 2-tuple.
* IMAGELIST_ADD: Loads image into image-list. Param "value" must be full path to png/bmp image file. Image size should be the same as size in image-list (but not required). Gets int icon index, or None if cannot load.
* IMAGELIST_DELETE: Deletes one icon. Param "value" is int icon index (0-based).
* IMAGELIST_DELETE_ALL: Deletes all icons.
* IMAGELIST_PAINT: Paints single icon on given canvas, at given coords. Param "value" must be tuple (canvas_id, x, y, icon_index). Value canvas_id can be 0 for testing paintbox in CudaText.

===image_proc===

 image_proc(id_image, id_action, value="")

Perform action on image object.

Param "id_image" is int handle of image. It is required for all actions, except IMAGE_CREATE, where it should be 0.

Possible values of "id_action":

* IMAGE_CREATE: Creates new image object. Gets int handle of this image. Param "value" must be int handle of owner form of object.
** If it is form handle from dlg_proc, object will be deleted after deletion of this form.
** If it is 0, main application form is used as owner, and object will be persistent.

* IMAGE_GET_SIZE: Gets current image size as 2-tuple (width, height).
* IMAGE_LOAD: Reads picture file into image object. Param "value" must be full file path (png, jpg, bmp, gif, ico).
* IMAGE_PAINT: Paints image object on given canvas, at given coords. Param "value" must be tuple (canvas_id, x, y). Value canvas_id can be 0, for testing paintbox in CudaText.
* IMAGE_PAINT_SIZED: Paints image object on given canvas, resized to given rectangle. Param "value" must be tuple (canvas_id, x1, y1, x2, y2).

===button_proc===

 button_proc(id_button, id_action, value="")

Perform action on extended button (control type "button_ex").

Param "id_button" is int handle of button.

Possible values of "id_action":

* BTN_UPDATE: Repaints button.
* BTN_GET_TEXT: Gets caption string.
* BTN_SET_TEXT: Sets caption string.
* BTN_GET_HINT: Gets hint (tooltip) string.
* BTN_SET_HINT: Sets hint string.
* BTN_GET_ENABLED: Gets enabled state, bool.
* BTN_SET_ENABLED: Sets enabled state. Param "value" must be bool.
* BTN_GET_VISIBLE: Gets visible state, bool.
* BTN_SET_VISIBLE: Sets visible state. Param "value" must be bool.
* BTN_GET_CHECKED: Gets checked state, bool.
* BTN_SET_CHECKED: Sets checked state. Param "value" must be bool.
* BTN_GET_IMAGELIST: Gets handle of image-list for button.
* BTN_SET_IMAGELIST: Sets handle of image-list. Param "value" must be int handle.
* BTN_GET_IMAGEINDEX: Gets icon index (in attached image-list).
* BTN_SET_IMAGEINDEX: Sets icon index. Param "value" must be int index (0-based), or -1 for none. To show icon, you must also set appropriate kind of button.
* BTN_GET_MENU: Gets int handle of submenu. It can be passed to menu_proc(h, MENU_SHOW).
* BTN_SET_MENU: Sets int handle of submenu. It can be handle created by menu_proc(0, MENU_CREATE).
* BTN_GET_KIND: Gets kind of button. Int value, one of BTNKIND_nnn constants.
* BTN_SET_KIND: Sets kind of button.
* BTN_GET_BOLD: Gets bold-style of button, bool.
* BTN_SET_BOLD: Sets bold-style. Param "value" must be bool.
* BTN_GET_ARROW: Gets dropdown arrow visible flag, bool.
* BTN_SET_ARROW: Sets dropdown arrow visible flag. Param "value" must be bool.
* BTN_GET_ARROW_ALIGN: Gets alignment of dropdown arrow, as str: "L", "R", "C".
* BTN_SET_ARROW_ALIGN: Sets alignment of dropdown arrow. Param "value" must be str: "L", "R", "C".
* BTN_GET_FOCUSABLE: Gets focusable state, bool.
* BTN_SET_FOCUSABLE: Sets focusable state. Param "value" must be bool.
* BTN_GET_FLAT: Gets flat state, bool.
* BTN_SET_FLAT: Sets flat state. Param "value" must be bool.
* BTN_GET_DATA1: Gets data1 string. Data1 is used for toolbar buttons, contains command of button: str(int_command) or callback.
* BTN_SET_DATA1: Sets data1. Param "value" must be callback: [[#Callback_param]].
* BTN_GET_DATA2: Gets data2 string. Data2 is currently not used by app.
* BTN_SET_DATA2: Sets data2 string.
* BTN_GET_WIDTH: Gets width (in pixels).
* BTN_SET_WIDTH: Sets width.
* BTN_GET_ITEMS: Gets choice items, used for kind=BTNKIND_TEXT_CHOICE, as "\n"-separated strings.
* BTN_SET_ITEMS: Sets choice items. Param "value" must be str, "\n"-separated strings.
* BTN_GET_ITEMINDEX: Gets choice index, used for kind=BTNKIND_TEXT_CHOICE.
* BTN_SET_ITEMINDEX: Sets choice index. Param "value" must be int >=0, or -1 for none.

Note: Toolbars contain several "button_ex" objects, which are anchored one to another (horizontally or vertically). You can also construct such toolbar by hands. API toolbar_proc() don't allow to specify kind of buttons, it sets kind from button properties.

===more===

=Editor class=

Editor class has methods to work with editor. Global objects of Editor exist:

* "ed": refers to currently focused editor (in any tab).
* "ed_con_log": refers to log field (multi-line) in the "Console" panel.
* "ed_con_in": refers to input field (single line) in the "Console" panel.

==Carets==
===Editor.get_carets===

 get_carets()

Returns list of 4-tuples, each item is info about one caret: (PosX, PosY, EndX, EndY).

* PosX is caret's column (0-base). Tab-chars give x increment 1, like others.
* PosY is caret's line (0-base).
* EndX/EndY is position of selection edge for this caret. Both -1 if no selection for caret.

Example shows text of first caret's selection:

<syntaxhighlight lang="Python">
    carets = ed.get_carets()
    x1, y1, x2, y2 = carets[0]
    if y2>=0:
        # sort (y,x) pairs
        if (y1, x1)>(y2, x2):
            x1, y1, x2, y2 = x2, y2, x1, y1
        s = ed.get_text_substr(x1, y1, x2, y2)
        msg_status('Selection: '+s)
</syntaxhighlight>

===Editor.set_caret===

 set_caret(posx, posy, endx=-1, endy=-1, id=CARET_SET_ONE, options=0)

Controls carets. Possible values of "id":

* CARET_SET_ONE: Removes multi-carets and sets single caret with given position (posx, posy, endx, endy). To place caret without selection, set both "endx", "endy" to -1.
* CARET_ADD: Adds caret (multi-carets feature) with given position. Returns number of carets after that.
* CARET_DELETE_ALL: Deletes all carets. Note: you must add caret then to enable text editing to user.
* CARET_SET_INDEX + N, where N is 0...1e6: Changes single caret with index N to given position.
* CARET_DELETE_INDEX + N, where N is 0...1e6: Deletes single caret with index N.

Param "options" must be 0 or sum of the following flags:

* CARET_OPTION_NO_SCROLL: Don't scroll to new caret position. For id=CARET_SET_ONE.
* CARET_OPTION_UNFOLD: If caret placed into folded line, unfold that line. For id=CARET_SET_ONE.

==Text read/write==

===Editor.get_text_all===

 get_text_all()

Gets entire text in the editor, as str.
Gives "\n" as line-breaks.

===Editor.set_text_all===

 set_text_all(text)

Sets entire text in the editor, to given str.
Text can have any line-breaks, they will be converted to currently used line-breaks.
It cannot work with read-only editor (see get_prop/set_prop and PROP_RO).

===Editor.get_text_line===

 get_text_line(index, max_len=0)

Gets single line (str) with given index (0-based).
Gets None if index incorrect.

If param "max_len" is non-zero, and UTF-8 length of given line is greater than "max_len", function returns empty str. This allows to skip huge lines.

===Editor.set_text_line===

 set_text_line(index, text)

Sets single line (str) with given index (0-based).
Text must be without line-breaks.
To add new line, pass index=-1.

===Editor.get_text_substr===

 get_text_substr(x1, y1, x2, y2)

Gets substring from position (x1, y1) to bigger position (x2, y2).

===Editor.delete===

 delete(x1, y1, x2, y2)

Deletes range from position (x1, y1) to bigger position (x2, y2).

* Too big x1/x2 are allowed (after line-end)
* Too big y2 means delete to end of file

Note: don't pass tuple from get_carets()[0], this tuple has not sorted pos=(x1, y1), end=(x2, y2), you need to sort them (first sort by y, then by x).

Example replaces selection of 1st caret with text:

<syntaxhighlight lang="Python">
        x0, y0, x1, y1 = ed.get_carets()[0]
        if (y0, x0) >= (y1, x1): #note that y first
            x0, y0, x1, y1 = x1, y1, x0, y0

        ed.set_caret(x0, y0)
        ed.delete(x0, y0, x1, y1)
        ed.insert(x0, y0, text)
</syntaxhighlight>

===Editor.insert===

 insert(x, y, text)

Inserts given text at position (x, y). If y too big, appends block to end (even to final line w/out line-end).
Text can be multi-line, all CR LF are converted to currently used line-breaks.

Gets 2-tuple (x, y) of position after inserted text. It is on the same line, if text is single line. Gets None if cannot insert.

===Editor.replace===

 replace(x1, y1, x2, y2, text)

Replaces range from position (x1, y1) to bigger position (x2, y2), with new text.

* Too big x1/x2 are allowed (after line-end)
* Too big y2 means delete to end of file

Function does the same as delete+insert, but

* optimized for replace inside one line (when y1==y2 and no line-breaks in text)
* for multi-line it also makes grouped-undo for delete+insert

Gets 2-tuple (x, y) of position after inserted text.

===Editor.replace_lines===

 replace_lines(y1, y2, lines)

Deletes whole lines from index y1 to y2, then inserts new lines from specified list.

* Index y1 must be valid index (0 to count-1)
* Index y2 can be less than y1 (to not delete), and can be too big (to delete lines to end)
* Param lines is list/tuple of str. Can be empty list to just delete lines. Inside items should not be "\n" and "\r": "\n" will generate additonal lines, "\r" not handled.

Gets bool: index y1 correct, replace done.

==Selection==

===Editor.get_text_sel===

 get_text_sel()

Returns selected text for 1st caret (empty, if no selection).

===Editor.get_sel_mode===

 get_sel_mode()

Gets current selection mode:

* SEL_NORMAL: normal (stream) selection; it doesn't mean that selection exists.
* SEL_COLUMN: column (vertical) selection.

===Editor.get_sel_lines===

 get_sel_lines()

Gets 2-tuple, indexes of first and last lines affected by first caret selection. Gets (-1,-1) if no selection.

===Editor.get_sel_rect, Editor.set_sel_rect===

 get_sel_rect()
 set_sel_rect(x1, y1, x2, y2)

Gets/sets coords of column selection.

Gets 4-tuple (x1, y1, x2, y2). All 0 if no column selection.

==Properties==

===Editor.get_line_count===

 get_line_count()

Gets number of lines.

===Editor.get_filename===

 get_filename(options="")

Gets filename (str) of the editor.

* Gets empty string for untitled tab.
* Gets string "?" if tab contains not normal text editor. See: get_prop(PROP_KIND).

If param "options" contains char "*", the real file name is always returned, even in hex/picture viewer mode.

===Editor.get_prop===

 get_prop(id, value="")

Gets editor's property.

Param "value" can be: str, number, bool (for bool it can be also "0"/"1"). Possible values of "id":

* PROP_GUTTER_ALL: bool: gutter (container for all gutter columns) is visible.
* PROP_GUTTER_STATES: bool: show gutter column "line states".
* PROP_GUTTER_NUM: bool: show gutter column "line numbers".
* PROP_GUTTER_FOLD: bool: show gutter column "folding".
* PROP_GUTTER_BM: bool: show gutter column "bookmarks".
* PROP_NEWLINE: str: kind of line endings. One of values "lf", "crlf", "cr".
* PROP_WRAP: int: word-wrap mode. One of WRAP_nnn values.
* PROP_RO: bool: read-only mode.
* PROP_MARGIN: int: position of fixed margin.
* PROP_MARGIN_STRING: str: user-defined margins positions, e.g. "20 25".
* PROP_INSERT: bool: insert/overwrite mode.
* PROP_MODIFIED: bool: editor is modified.
* PROP_MODIFIED_VERSION: int: counter which is incremented on each text change.
* PROP_RULER: bool: horz ruler is shown.

* PROP_LINE_STATE: int: state of the line with given index. One of LINESTATE_nnn values.
* PROP_LINE_STATES: list of int: list of line states (LINESTATE_nnn values) for all lines.
* PROP_LINE_STATES_UPDATED: list of bool: list of "updated" flags for all lines, each flag shows that its line was added/changed since the last clearing of this "updated" flag.

* PROP_LINE_NUMBERS: int: style of line numbers. One of LINENUM_nnn values.
* PROP_LINE_TOP: int: index of line visible at the top of editor.
* PROP_LINE_BOTTOM: int: index of line visible at the bottom of editor (considers word wrap).

* PROP_SCROLL_VERT: int: approximate vertical scroll position. Index in WrapInfo list, you can read this list via get_wrapinfo().
* PROP_SCROLL_HORZ: int: approximate horizontal scroll position.
* PROP_SCROLL_VERT_SMOOTH: int: smooth vertical scroll position. In pixels.
* PROP_SCROLL_HORZ_SMOOTH: int: smooth horizontal scroll position. In pixels.
* PROP_SCROLL_VERT_INFO: int: dict with all available info about vertical scroll.
* PROP_SCROLL_HORZ_INFO: int: dict with all available info about horizontal scroll.

* PROP_COLOR: int: color property. Value must be one of COLOR_ID_nnn values. Gets None for incorrect id.
* PROP_ENC: str: encoding name. Names are listed at [[CudaText#Encodings]].
* PROP_LEXER_FILE: str: name of lexer for entire file (empty str if none is active).
* PROP_LEXER_POS: str: name of lexer at specified position. Param "value" must be 2-tuple (column, line), or string str(column)+','+str(line), with 0-based indexes.
* PROP_LEXER_CARET: str: name of lexer at the position of 1st caret.
* PROP_INDEX_GROUP: int: index of group with editor's tab, 0-based.
* PROP_INDEX_TAB: int: index of editor's tab in group, 0-based.
* PROP_UNPRINTED_SHOW: bool: unprinted chars: global enable-flag.
* PROP_UNPRINTED_SPACES: bool: unprinted chars: show spaces/tabs.
* PROP_UNPRINTED_SPACES_TRAILING: bool: unprinted chars: show spaces/tabs only at end of lines.
* PROP_UNPRINTED_ENDS: bool: unprinted chars: show line ends.
* PROP_UNPRINTED_END_DETAILS: bool: unprinted chars: show line end details.
* PROP_TAG: str: some string attached to editor. Value must be "key:defvalue" or simply "defvalue". Saved value for "key" is returned, or "defvalue" returned if value for key was not set. Empty key means key "_".
* PROP_CARET_VIEW: 3-tuple: shape of caret, normal mode. Tuple contents is (int_width, int_height, bool_empty_inside). Width/height<0 means value in percents.
* PROP_CARET_VIEW_OVR: 3-tuple: shape of caret, overwrite mode.
* PROP_CARET_VIEW_RO: 3-tuple: shape of caret, read-only mode.
* PROP_CARET_VIRTUAL: bool: caret position is allowed after line-ends.
* PROP_CARET_STOP_UNFOCUSED: bool: caret blinks only when editor is focused.
* PROP_MACRO_REC: bool: currently macro is recording.
* PROP_MARKED_RANGE: 2-tuple with line indexes of "marked range"; (-1, -1) if range not set.
* PROP_VISIBLE_LINES: int: max count of lines that fit to window (doesn't consider word wrap).
* PROP_VISIBLE_COLUMNS: int: max count of columns that fit to window.
* PROP_PICTURE: properties of picture file as 3-tuple: (picture_filename, size_x, size_y), or None if not picture loaded in tab. For picture ed.get_filename() gets "?".
* PROP_MINIMAP: bool: minimap is visible.
* PROP_MICROMAP: bool: micromap is visible.
* PROP_LINK_AT_POS: str: URL in the document, at given position. Value must be str(pos_x)+","+str(pos_y).
* PROP_TAB_SPACES: bool: tab-key inserts spaces (not tab-char).
* PROP_TAB_SIZE: int: size of tab-char.
* PROP_TAB_COLLECT_MARKERS: bool: tab-key collects (jumps to and deletes) markers (if markers placed).
* PROP_TAB_TITLE: str: title of tab, useful for untitled tabs, for tabs with picture files.
* PROP_TAB_COLOR: int: color of tab containing editor; COLOR_NONE if not set.
* PROP_TAB_ICON: int: index of tab icon, ie index in imagelist, which handle you can get via app_proc(PROC_GET_TAB_IMAGELIST).
* PROP_TAB_ID: int: unique tab's identifier (one number for main/secondary editors in tab), it is not changed when tab is moved.
* PROP_INDENT_SIZE: int: size of indent for Indent/Unindent commands. N>0: indent in spaces, N<0: indent in tabs, N=0: indent from PROP_TAB_SIZE/PROP_TAB_SPACES.
* PROP_INDENT_KEEP_ALIGN: bool: command Unindent keeps alignment of block edge, ie don't unindent if any line reached column 0.
* PROP_INDENT_AUTO: bool: makes next line also indented on Enter command.
* PROP_INDENT_KIND: int: kind of auto-indented line, see description of app option "indent_kind".
* PROP_FOLD_ALWAYS: bool: always show icons on "folding" gutter bar, otherwise show them only on mouse over.
* PROP_FOLD_ICONS: int: icon set for "folding" gutter bar. Possible values: 0, 1.
* PROP_FOLD_TOOLTIP_SHOW: bool: show floating tooltip when mouse hovers [...] mark for folded block.
* PROP_LAST_LINE_ON_TOP: bool: allow to scroll control, so last line shows on top.
* PROP_HILITE_CUR_COL: bool: highlight current column.
* PROP_HILITE_CUR_LINE: bool: highlight current line.
* PROP_HILITE_CUR_LINE_MINIMAL: bool: highlight current line, only minimal part of line.
* PROP_HILITE_CUR_LINE_IF_FOCUS: bool: highlight current line, only when editor focused.
* PROP_CODETREE: bool: enable standard code-tree filling.
* PROP_CODETREE_MODIFIED_VERSION: modification version of the editor for the moment of code-tree filling. See PROP_MODIFIED_VERSION.
* PROP_EDITORS_LINKED: bool: enable sharing of the same text by primary/secondary editors in file tab.
* PROP_CELL_SIZE: 2-tuple of int: size in pixels of average char cell.
* PROP_ONE_LINE: bool: editor has single-line mode. (Usual editors are multi-line.)
* PROP_MODERN_SCROLLBAR: bool: use custom-drawn themed scrollbars.
* PROP_SAVE_HISTORY: bool: allows to save history (caret, scroll pos, folding etc) on file closing.
* PROP_PREVIEW: bool: editor is inside "Preview tab" (it has italic caption).
* PROP_UNDO_GROUPED: bool: editor undo/redo is grouped.
* PROP_UNDO_LIMIT: int: max count of simple actions, which can be undone.
* PROP_UNDO_DATA: str: string representation of Undo data.
* PROP_REDO_DATA: str: string representation of Redo data.
* PROP_ZEBRA: int: if 0, zebra mode is not active; if >0, it is alpha-blend value (1..255) of active zebra mode.
* PROP_ACTIVATION_TIME: int: relative time (in OS timer ticks) when tab ("main" or "brother" editor in the same tab) was last focused. It's 0 for not yet focused tabs. It's None for editors created by dlg_proc().
* PROP_KIND: str: kind of UI control in the tab.
** "text": normal editor
** "bin": binary viewer
** "pic": picture

* PROP_SPLIT: 2-tuple: information about primary/secondary editors splitting as tuple (split_kind, split_pos).
** "split_kind": str: "-" (not splitted), "v" (splitted vertically), "h" (splitted horizontally).
** "split_pos": int: part of entire size for secondary editor, multiplied by 1000 (e.g. 500 is half of size).

* PROP_SAVING_FORCE_FINAL_EOL: bool: on saving file, ensure the newline at end of document.
* PROP_SAVING_TRIM_SPACES: bool: on saving file, trim trailing whitespaces.
* PROP_SAVING_TRIM_FINAL_EMPTY_LINES: bool: on saving file, trim redundant empty lines at end of document.

* PROP_HANDLE_SELF: int: handle of editor object, for which get_prop is called. This handle is unique among all objects in program (it is memory address). Note that ed.h==0, it is virtual handle for the focused editor. This API gets the real handle.
* PROP_HANDLE_PRIMARY: int: handle of editor object, which is primary editor in a file tab (always visible). None for separate editors.
* PROP_HANDLE_SECONDARY: int: handle of editor object, which is secondary editor in a file tab (visible only when file tab is splitted). None for separate editors.
* PROP_HANDLE_PARENT: int: handle of parent of editor object, or 0 if no such parent. This handle is needed to dock forms near the editor.

* PROP_COORDS: 4-tuple of int: rectangle of entire editor area, relative to screen.
* PROP_RECT_CLIENT: 4-tuple of int: rectangle of entire editor area, relative to editor.
* PROP_RECT_TEXT: 4-tuple of int: rectangle of text-only editor area (excluding gutter/minimap/etc), relative to editor.

* PROP_V_MODE: int: for binary viewer, viewer current mode, one of VMODE_nnn constants.
* PROP_V_POS: int: for binary viewer, scroll position.
* PROP_V_SEL_START: int: for binary viewer, selection start offset.
* PROP_V_SEL_LEN: int: for binary viewer, selection length.
* PROP_V_WIDTH: int: for binary viewer, width of text in mode VMODE_BINARY.

===Editor.set_prop===

 set_prop(id, value)

Sets editor's property.

Param "value" can be: str, number, bool (for bool it can be also "0"/"1"), tuple of simple type. Possible values of "id":

* PROP_GUTTER_ALL: bool: gutter (container for all gutter columns) is visible.
* PROP_GUTTER_STATES: bool: show gutter column "line states".
* PROP_GUTTER_NUM: bool: show gutter column "line numbers".
* PROP_GUTTER_FOLD: bool: show gutter column "folding".
* PROP_GUTTER_BM: bool: show gutter column "bookmarks".
* PROP_WRAP: int: word-wrap mode. One of WRAP_nnn values.
* PROP_RO: bool: read-only mode.
* PROP_NEWLINE: str: kind of line endings. One of values "lf", "crlf", "cr".
* PROP_MARGIN: int: position of fixed margin.
* PROP_MARGIN_STRING: str: space-separated user-margins columns.
* PROP_INSERT: bool: insert/overwrite mode.
* PROP_MODIFIED: bool: editor is modified.
* PROP_RULER: bool: show ruler.
* PROP_COLOR: color property, value must be 2-tuple (COLOR_ID_nnnn, int_color_value).
* PROP_LINE_TOP: int: index of line visible at the editor top.
* PROP_LINE_NUMBERS: int: style of line numbers. One of LINENUM_nnn values.
* PROP_LINE_STATE: 2-tuple: state of the line with given index. 2-tuple (line_index, LINESTATE_nnn).
* PROP_LINE_STATES_UPDATED: currently supports writing only empty string value, writing it means clearing of "updated" flags for all lines.

* PROP_SCROLL_VERT: int: approximate vertical scroll position. Index in WrapInfo list, you can read this list via get_wrapinfo().
* PROP_SCROLL_HORZ: int: approximate horizontal scroll position.
* PROP_SCROLL_VERT_SMOOTH: int: smooth vertical scroll position. In pixels.
* PROP_SCROLL_HORZ_SMOOTH: int: smooth horizontal scroll position. In pixels.

* PROP_ENC: str: encoding name. Names listed at [[CudaText#Encodings]].
* PROP_LEXER_FILE: str: name of lexer.
* PROP_INDEX_GROUP: int: index of group with editor's tab, 0-based.
* PROP_INDEX_TAB: int: index of editor's tab in group, 0-based.
* PROP_UNPRINTED_SHOW: bool: unprinted chars: global enable-flag.
* PROP_UNPRINTED_SPACES: bool: unprinted chars: show spaces/tabs.
* PROP_UNPRINTED_SPACES_TRAILING: bool: unprinted chars: show spaces/tabs only at end of lines.
* PROP_UNPRINTED_ENDS: bool: unprinted chars: show line ends.
* PROP_UNPRINTED_END_DETAILS: bool: unprinted chars: show line end details.
* PROP_TAG: str: some string attached to editor. Param text must be pair "key:value" or simply "value", this sets value for specified key (internally it is dictionary). Empty key means key "_".
* PROP_CARET_VIEW: 3-tuple: shape of caret, normal mode. Tuple contents is (int_width, int_height, bool_empty_inside). Width/height<0 means value in percents.
* PROP_CARET_VIEW_OVR: 3-tuple: shape of caret, overwrite mode.
* PROP_CARET_VIEW_RO: 3-tuple: shape of caret, read-only mode.
* PROP_CARET_VIRTUAL: bool: caret position is allowed after line-ends.
* PROP_CARET_STOP_UNFOCUSED: bool: caret blinks only when editor is focused.
* PROP_MARKED_RANGE: line indexes of "marked range", value is 2-tuple (index1, index2) or (-1, -1) to remove this range.
* PROP_MINIMAP: bool: minimap is visible.
* PROP_MICROMAP: bool: micromap is visible.
* PROP_TAB_SPACES: bool: tab-key inserts spaces.
* PROP_TAB_SIZE: int: size of tab-char.
* PROP_TAB_COLLECT_MARKERS: bool: tab-key collects (jumps to and deletes) markers.
* PROP_TAB_COLOR: int: color of tab containing editor; set COLOR_NONE to reset.
* PROP_TAB_TITLE: str: title of tab, useful for untitled tabs.
* PROP_TAB_ICON: int: index of tab icon, ie index in imagelist, which handle you can get via app_proc(PROC_GET_TAB_IMAGELIST).
* PROP_INDENT_SIZE: int: size of indent for Indent/Unindent commands. N>0: indent in spaces, N<0: indent in tabs, N=0: indent from PROP_TAB_SIZE/PROP_TAB_SPACES.
* PROP_INDENT_KEEP_ALIGN: bool: command Unindent keeps alignment of block edge, ie don't unindent if any line reached column 0.
* PROP_INDENT_AUTO: bool: makes next line also indented on Enter command.
* PROP_INDENT_KIND: int: kind of auto-indented line, see description of app option "indent_kind".
* PROP_FOLD_ALWAYS: bool: always show icons on "folding" gutter bar, otherwise show them only on mouse over.
* PROP_FOLD_ICONS: int: icon set for "folding" gutter bar. Possible values: 0, 1.
* PROP_FOLD_TOOLTIP_SHOW: bool: show floating tooltip when mouse hovers [...] mark for folded block.
* PROP_LAST_LINE_ON_TOP: bool: allow to scroll control, so last line shows on top.
* PROP_HILITE_CUR_COL: bool: highlight current column.
* PROP_HILITE_CUR_LINE: bool: highlight current line.
* PROP_HILITE_CUR_LINE_MINIMAL: bool: highlight current line, only minimal part of line.
* PROP_HILITE_CUR_LINE_IF_FOCUS: bool: highlight current line, only when editor focused.
* PROP_CODETREE: bool: enable standard code-tree filling.
* PROP_EDITORS_LINKED: bool: enable sharing of the same text by primary/secondary editors in file tab.
* PROP_ONE_LINE: bool: editor has single-line mode.
* PROP_MODERN_SCROLLBAR: bool: use custom-drawn themed scrollbars.
* PROP_SAVE_HISTORY: bool: allows to save history (caret, scroll pos, folding etc) on file closing.
* PROP_UNDO_GROUPED: bool: editor undo/redo is grouped.
* PROP_UNDO_LIMIT: int: max count of simple actions, which can be undone.
* PROP_UNDO_DATA: str: string representation of Undo data.
* PROP_REDO_DATA: str: string representation of Redo data.
* PROP_ZEBRA: int: if 0, zebra mode is not active; if >0, it is alpha-blend value (1..255) of active zebra mode.

* PROP_SPLIT: 2-tuple: information about primary/secondary editors splitting as tuple (split_kind, split_pos).
** "split_kind": str: "-" (not splitted), "v" (splitted vertically), "h" (splitted horizontally).
** "split_pos": int: part of entire size for secondary editor, multiplied by 1000 (e.g. 500 is half of size).

* PROP_SAVING_FORCE_FINAL_EOL: bool: on saving file, ensure the newline at end of document.
* PROP_SAVING_TRIM_SPACES: bool: on saving file, trim trailing whitespaces.
* PROP_SAVING_TRIM_FINAL_EMPTY_LINES: bool: on saving file, trim redundant empty lines at end of document.

* PROP_V_MODE: int: for binary viewer, viewer current mode, one of VMODE_nnn constants.
* PROP_V_POS: int: for binary viewer, scroll position.
* PROP_V_SEL_START: int: for binary viewer, selection start offset.
* PROP_V_SEL_LEN: int: for binary viewer, selection length.
* PROP_V_WIDTH: int: for binary viewer, width of text in mode VMODE_BINARY.

===props vs options===

Many get_prop/set_prop ids correspond to CudaText options. List of correspoding pairs:

* PROP_CARET_VIRTUAL - caret_after_end
* PROP_GUTTER_ALL - gutter_show
* PROP_GUTTER_BM - gutter_bookmarks
* PROP_GUTTER_FOLD - gutter_fold
* PROP_HILITE_CUR_COL - show_cur_column
* PROP_HILITE_CUR_LINE - show_cur_line
* PROP_HILITE_CUR_LINE_MINIMAL - show_cur_line_minimal
* PROP_HILITE_CUR_LINE_IF_FOCUS - show_cur_line_only_focused
* PROP_INDENT_AUTO - indent_auto
* PROP_INDENT_KEEP_ALIGN - unindent_keeps_align
* PROP_INDENT_KIND - indent_kind
* PROP_INDENT_SIZE - indent_size
* PROP_LAST_LINE_ON_TOP - show_last_line_on_top
* PROP_MARGIN - margin
* PROP_MARGIN_STRING - margin_string
* PROP_MICROMAP - micromap_show
* PROP_MINIMAP - minimap_show
* PROP_RULER - ruler_show
* PROP_TAB_SIZE - tab_size
* PROP_TAB_SPACES - tab_spaces
* PROP_UNPRINTED_ENDS - unprinted_ends
* PROP_UNPRINTED_END_DETAILS - unprinted_end_details
* PROP_UNPRINTED_SHOW - unprinted_show
* PROP_UNPRINTED_SPACES - unprinted_spaces
* PROP_UNPRINTED_SPACES_TRAILING - unprinted_spaces_trailing
* PROP_WRAP - wrap_mode

===Editor.bookmark===

 bookmark(id, nline, nkind=1, ncolor=-1, text="", auto_del=True, show=True, tag=0)

Controls bookmarks. Possible values of "id":

* BOOKMARK_GET_ALL: Gets list of bookmarks, as list of dict. Param "nline" ignored. Dict keys are: "line", "kind", "tag", "hint", "auto_del", "show_in_list".
* BOOKMARK_GET_LIST: Gets list of line indexes, which have bookmarks. Param "nline" ignored.
* BOOKMARK_GET_PROP: Gets properties of bookmark at line index, given by param "nline". Gets dict, like for BOOKMARK_GET_ALL, or None.

* BOOKMARK_SET: Sets bookmark.
** Param "nline": int: line index of bookmark.
** Param "nkind": int: kind of bookmark: 1 means usual bookmark with usual color and icon. Other kind values mean custom bookmark, which must be setup via BOOKMARK_SETUP.
** Param "text": str: tooltip, shown when mouse moves over bookmark gutter icon.
** Param "auto_del": bool: auto delete bookmark on deleting its text line.
** Param "show": bool: show bookmark in "Go to bookmark" dialog.
** Param "tag": int: some value attached to bookmark.

* BOOKMARK_CLEAR: Removes bookmark from line, specified by "nline" param.
* BOOKMARK_CLEAR_ALL: Removes all bookmarks ("nline" ignored).
* BOOKMARK_DELETE_BY_TAG: Removes all bookmarks, which have tag, given by "tag" param.

* BOOKMARK_SETUP: Configures bookmarks with kind, given by "nkind" param.
** Param "ncolor": Color of bookmarked line.
*** Can be COLOR_NONE to not use background color.
*** Can be COLOR_DEFAULT to use current themed color.
** Param "text": Path to icon file for gutter, 16x16 .bmp or .png file. Empty str: don't show icon.

Additional internal list Bookmarks2 exists, which holds list of background bookmarks. They have lower paint priority than usual bookmarks, so background bookmark is painted only if usual bookmark not exists. Actions BOOKMARK2_* are used for Bookmarks2 list, actions have the same meaning. Background bookmarks don't have gutter icon and mouse-over tooltip. They share the single setup with usual bookmarks.

* BOOKMARK2_GET_ALL
* BOOKMARK2_GET_PROP
* BOOKMARK2_SET
* BOOKMARK2_CLEAR
* BOOKMARK2_CLEAR_ALL
* BOOKMARK2_DELETE_BY_TAG

Notes:

* Param "nkind" must be in the range 1..63.
* Param "nkind" values 2..9 have setup by default: they have blue icons "1" to "8".

===Editor.decor===

 decor(id, line=-1, tag=0, text="", color=0, bold=False, italic=False, image=-1, auto_del=True)

Controls decorations on gutter. It is used to show some visual marks, which look like bookmark icons, but independent of bookmarks. Possible values of "id":

* DECOR_GET_ALL: Gets list of all decorations, as list of dict, or None.
* DECOR_GET: Gets decoration for single line, as dict, or None. Params used: "line".
* DECOR_SET: Sets decoration for single line, overwriting existing item for that line. Gets bool: line index correct, item added. Params used:
** "line": int, line index.
** "tag": int, some value attached to item.
** "text": str, text to show; decoration will be text.
** "color": int, color of text decoration.
** "bold": bool, use bold font for text decoration.
** "italic": bool, use italic font for text decoration.
** "image": int, icon index from decoration image-list; decoration will be icon, if text is empty.
** "auto_del": bool, auto-delete decoration, when its line is deleted.

* DECOR_DELETE_BY_LINE: Deletes single decoration for given line. Params used: "line".
* DECOR_DELETE_BY_TAG: Deletes all decorations for given tag. Param used: "tag".
* DECOR_DELETE_ALL: Deletes all decorations.
* DECOR_GET_IMAGELIST: Gets int handle of decoration image-list (default size is 16x16).

===Editor.folding===

 folding(id, index=-1, item_x=-1, item_y=-1, item_y2=-1, item_staple=False, item_hint="")

Performs action on folding ranges. Possible values of "id":

* FOLDING_GET_LIST: Gets list of folding ranges. Params used: none except "id". Gets list of tuples (y, y2, x, staple, folded), or None.
** "y": int: line of range start.
** "y2": int: line of range end. If y==y2, then range is simple and don't have gutter-mark and staple.
** "x": int: x-offset of range start (char index in start line).
** "staple": bool: range has block staple.
** "folded": bool: range is currently folded.

* FOLDING_GET_LIST_FILTERED: Gets list of folding ranges, which contain given range: line indexes from param "item_y" to param "item_y2" (inclusive). If item_y<0, then no filtering is done. You can perform this filtering from the result of FOLDING_GET_LIST, but it's slower.

* FOLDING_FOLD: Folds range with given index (index in list, from FOLDING_GET_LIST). Params used: "index".
* FOLDING_FOLD_ALL: Folds all ranges.
* FOLDING_FOLD_LEVEL: Unfolds all ranges, then folds ranges starting with given nesting level. Params used: "index": nesting level, 0..9.

* FOLDING_UNFOLD: Unfolds range with given index (index in list, from FOLDING_GET_LIST). Params used: "index".
* FOLDING_UNFOLD_ALL: Unfolds all ranges.
* FOLDING_UNFOLD_LINE: Unfolds line with given index (index in lines list). Params used: "index".

* FOLDING_ADD: Adds folding range. Life time of this range is until lexer analisys runs (it clears ranges and adds ranges from lexer), which runs after any text change. Params used:
** "item_x": char index (offset in line) of range start.
** "item_y": line index of range start.
** "item_y2": line index of range end.
** "item_staple" (optional): bool, range has block staple.
** "item_hint" (optional): str, hint which is shown when range is folded.
** "index": if it's valid range index (0-based), range inserts at this index, otherwise range appends.

* FOLDING_DELETE: Deletes folding range with given index (index in list, from FOLDING_GET_LIST). Params used: "index".
* FOLDING_DELETE_ALL: Deletes all folding ranges. Params used: none except "id".
* FOLDING_FIND: Finds index of range (index in list, from FOLDING_GET_LIST). Gets None if not found. Params used: "item_y" is line index at which range begins.
* FOLDING_CHECK_RANGE_INSIDE: For 2 ranges, which indexes given by "index" and "item_x", detects: 1st range is inside 2nd range. Gets bool. Gets False if indexes incorrect.
* FOLDING_CHECK_RANGES_SAME: For 2 ranges, which indexes given by "index" and "item_x", detects: ranges are "equal" (x, y, y2 in ranges may differ). Gets bool. Gets False if indexes incorrect.

===Editor.get_sublexer_ranges===

 get_sublexer_ranges()

Gets list of ranges which belong to nested lexers (sublexers of current lexer for entire file, e.g. "JavaScript" inside "PHP", "CSS" inside "HTML"). Gets list of 5-tuples, or None if no ranges. Each tuple is:

* str: sublexer name
* int: start column (0-based)
* int: start line (0-based)
* int: end column
* int: end line

===Editor.get_token===

 get_token(id, index1=0, index2=0)

Gets info about lexer "tokens". "Token" is minimal text fragment for lexer, e.g. one indentifier, one operator, one whole comment, one whole string. Each token has its color from lexer properties or color theme.

Possible values of "id":

* TOKEN_LIST: Gets all tokens, as list of dict. Params "index1", "index2" are ignored. Gets None if no lexer active. Dict keys are:
** "x1": start column (0-based)
** "y1": start line (0-based)
** "x2": end column
** "y2": end line
** "str": text of token (can be multi-line with "\n")
** "style": lexer style of token (lexer dependent)

* TOKEN_LIST_SUB: Like TOKEN_LIST, but gets tokens only for given lines range, from "index1" to "index2" inclusive.

===Editor.get_wrapinfo===

 get_wrapinfo()

Gets info about wrapped lines. It allows to calculate, at which positions long lines are wrapped (when wrap mode is on). It allows to see, which text parts are folded.

Gets list of dict, or None. Dict items has keys:

* "line": int: Original line index, for this part.
* "char": int: Char index (1-based, for UTF-16 stream of chars), at which this part starts. It is >1, for next parts of long wrapped line.
* "len": int: Length of this part. It equals to entire line length, if line is not wrapped.
* "indent": int: Screen indent in spaces, for this part, it's used in rendering when option "Show wrapped parts indented" is on.
* "final": int: State of this part. 0: final part of the entire line; 1: partially folded part; 2: first or middle part of the entire line.
* "initial": bool: True if part is initial for the entire (wrapped) line, False if it is continuation (ie, wrapped) part.

===Editor.markers===

 markers(id, x=0, y=0, tag=0, len_x=0, len_y=0)

Controls markers (used e.g. in Snippets plugin). Possible values of "id":

* MARKERS_GET: Gets list of markers. Each list item is [x, y, len_x, len_y, tag]. Gets None if no markers.

* MARKERS_ADD: Adds marker. Also gets number of markers. Params:
** "x", "y": Start of marker (like caret pos).
** "tag">0 is needed if you want to place multi-carets when command "goto last marker (and delete)" runs. All markers with the same tag>0 will get multi-carets (after markers will be deleted).
** "len_x", "len_y" are needed if you want to place selection at marker, when "goto last marker" command goes to this marker.
*** if len_y==0: len_x is length of selection (single line),
*** if len_y>0: len_y is y-delta of selection-end, and len_x is absolute x-pos of selection-end.

* MARKERS_DELETE_ALL: Deletes all markers.
* MARKERS_DELETE_LAST: Deletes last added marker.
* MARKERS_DELETE_BY_TAG: Deletes all markers for specified "tag".

===Editor.attr===

 attr(id, tag=0, x=0, y=0, len=0,
      color_font=COLOR_NONE, color_bg=COLOR_NONE, color_border=COLOR_NONE,
      font_bold=0, font_italic=0, font_strikeout=0,
      border_left=0, border_right=0, border_down=0, border_up=0,
      show_on_map=False )

Controls additional color attributes. Possible values of "id":

* MARKERS_ADD: Adds fragment with specified properties. Also gets number of fragments. Props:
** "tag": any int value attached to fragment (several plugins must add fragments with different tags, to be able to remove only fragments for them)
** "x", "y": position of fragment start (like caret).
** "len": length of fragment.
** "color_nnnn": RGB color values for font, background, borders. E.g. 0x0000FF is red, 0x00FF00 is green.
** "font_nnnn": font attributes: 0 - off, 1 - on.
** "border_nnnn": border types for edges, int value 0..6: none, solid, dash, solid 2pixel, dotted, rounded, wave.
** "show_on_map": paint this item on CudaText micromap.

* MARKERS_GET: Gets list of fragments, or None. Each item is list with int fields, in the same order as function params.
* MARKERS_DELETE_ALL: Deletes all fragments.
* MARKERS_DELETE_LAST: Deletes last added fragment.
* MARKERS_DELETE_BY_TAG: Deletes all fragments for specified "tag".

Note:

* "color_bg" value can be COLOR_NONE: it uses usual back-color.
* "color_font", "color_border" value can be COLOR_NONE: it uses usual text-color.

===Editor.hotspots===

 hotspots(id, tag=0, tag_str="", pos="")

Controls hotspot ranges. When mouse cursor moves in/out of hotspot, event on_hotspot is called.

Possible values of "id":

* HOTSPOT_ADD: Adds hotspot. Gets bool: params correct, hotspot added. Params:
** "pos": 4-tuple of int, text coords: (x_start, y_start, x_end, y_end)
** "tag": optional int value
** "tag_str": optional str value

* HOTSPOT_GET_LIST: Gets list of hotspots, or None. Each item is dict with keys:
** "pos": 4-tuple of int
** "tag": int
** "tag_str": str

* HOTSPOT_DELETE_ALL: Deletes all hotspots.
* HOTSPOT_DELETE_LAST: Deletes last hotspot.
* HOTSPOT_DELETE_BY_TAG: Deletes all hotspots with specified "tag".

==Misc==

===Editor.save===

 save(filename="")

Saves editor's tab to disk.

Shows save-as dialog for untitled tab.
If param filename not empty, uses it (untitled tab becomes titled).
Gets bool: file was saved.

===Editor.cmd===

 cmd(code, text="")

Command runner, it runs any command in editor by its int code.

See codes in module cudatext_cmd. Param text is needed for rare commands (e.g. by cCommand_TextInsert).

===Editor.focus===

 focus()

Activates editor's tab and focuses editor itself. It's needed when you want to activate inactive tab. You can get Editor objects of inactive tabs using ed_handles().

===Editor.lock, Editor.unlock===

 lock()
 unlock()

Functions lock, then unlock editor. "Locked" editor is not painted and shows only hourglass (or another) icon.

Call "lock" increases counter, "unlock" decreases this counter (it's safe to call "unlock" more times, counter will be 0). When counter is >0, editor is locked.

===Editor.convert===

 convert(id, x, y, text="")

Converts something in editor. Possible values of "id":

* CONVERT_CHAR_TO_COL: Convert char coordinates (x,y) to column coordinates (column,y), using current tab size.
* CONVERT_COL_TO_CHAR: Convert column coordinates (x,y) to char coordinates (chars,y).
* CONVERT_LINE_TABS_TO_SPACES: Convert line (param "text") from tab-chars to spaces, using current tab size. Gets str. Gets original line, if no tab-chars in it.
* CONVERT_SCREEN_TO_LOCAL: Convert pixel coordinates (x,y), from screen-related to control-related.
* CONVERT_LOCAL_TO_SCREEN: Convert pixel coordinates (x,y), from control-related to screen-related.
* CONVERT_PIXELS_TO_CARET: Convert pixel control-related coords (x,y) to caret position (column,line).
* CONVERT_CARET_TO_PIXELS: Convert caret position (column,line) to pixel control-related coords (x,y).

Gets None if params incorrect, or cannot calc result.

===Editor.complete===

 complete(text, len1, len2, selected=0, alt_order=False)

Shows auto-completion listbox with given items.

Function gets None and listbox stays open. When user chooses listbox item, its data is inserted.

* Param "text": string with items, must be formatted as shown in the [[ATSynEdit#Auto-completion_lists]].
* Param "len1": count of chars to the left of the caret, to be replaced.
* Param "len2": count of chars to the right of the caret, to be replaced.
* Param "selected": index of initially selected listbox item (0-based).
* Param "alt_order":
** alt_order=False: pass items in each line: prefix, id, desc. Listbox shows prefix at the left edge.
** alt_order=True: pass items in each line in such order: id, prefix, desc. Listbox shows id at the left edge. Use it if plugin needs to show long "prefixes".

Note: listbox disappears if you move caret or type text, unlike usual auto-completion listboxes (they can recalculate items for new caret pos).

===Editor.complete_alt===

 complete_alt(text, snippet_id, len_chars, selected=0)

Shows alternative completion listbox. This listbox allows to insert complex snippets, not only simple words. E.g. snippet text like "myobj.myfunc(${1:value1}, ${2:value2});".

Function gets None and listbox stays open. When user chooses listbox item, event on_snippet is called, with params:

* Param "snippet_id": value from complete_alt() call; on_snippet should handle only known value of snippet_id.
* Param "snippet_text": text of selected item (last column).

Function params:

* Param "text": "\n"-separated lines, one line per snippet. Each line has 3 columns "\t"-separated.
** Column 1 is shown on left side of listbox (good to show here name of function)
** Column 2 is shown on right side of listbox (good to show here type of function)
** Column 3 is snippet text in any format. Can contain "\t" but not "\n". Can have any chars escaped in any form.
* Param "snippet_id": any short string just to identify snippet kind between all plugins. E.g. plugin1/plugin2 may have snippets in different formats, they must handle only their snippets.
* Param "len_chars": listbox shows lefter than caret, by this count of chars.
* Param "selected": index of initially selected listbox item (0-based).

===Editor.gap===

 gap(id, num1, num2, tag=-1, size=0, color=COLOR_NONE)

Performs action on inter-line gaps (they don't overlap text above/below).
Possible values of "id":

* GAP_GET_ALL: Gets list of gaps. List of dict, or None. Dict keys are:
** "line": int: Line index; or -1 for gap before the first line.
** "tag": int: Tag.
** "size": int: Height in pixels.
** "color": int: Color.
** "bitmap": 2-tuple of int: Size of bitmap, or (0, 0) if no bitmap.

* GAP_MAKE_BITMAP: Action is needed only if you want to paint bitmap in gap, it's not needed for empty gaps. Makes new bitmap for future gap. Size of bitmap is (num1, num2). Gets 2-tuple (id_bitmap, id_canvas).
** "id_bitmap": bitmap handle, needed to later call GAP_ADD.
** "id_canvas": canvas handle, needed to paint on bitmap, by canvas_proc().

* GAP_ADD: Adds gap to editor. Gets bool: params correct, gap added. Params:
** "num1": int: Line index; can be -1 for gap before the first line.
** "num2": int: If 0, gap will be empty; otherwise it is bitmap handle (id_bitmap), which you got from GAP_MAKE_BITMAP.
** "tag": int: Some value, to separate gaps from several plugins.
** "size": int: If >0, it is gap height in pixels. If 0, gap height is calculated from bitmap handle.
** "color": int: If not COLOR_NONE, then it's gap background color.

* GAP_DELETE: Deletes gaps, for line indexes from num1 to num2.
* GAP_DELETE_ALL: Deletes all gaps.

Example plugin:

<syntaxhighlight lang="python">
from cudatext import *
class Command:
    def run(self):
        for i in range(ed.get_line_count()//2):
            self.do_gap(i*2)

    def do_gap(self, num):
        id_bitmap, id_canvas = ed.gap(GAP_MAKE_BITMAP, 600, 50)
        canvas_proc(id_canvas, CANVAS_SET_BRUSH, color=0xa0ffa0)
        canvas_proc(id_canvas, CANVAS_POLYGON, '200,0,300,30,200,50')
        canvas_proc(id_canvas, CANVAS_SET_BRUSH, color=0xffffff, style=BRUSH_CLEAR)
        canvas_proc(id_canvas, CANVAS_TEXT, x=230, y=10, text='gap %d'%(num+1))
        canvas_proc(id_canvas, CANVAS_SET_BRUSH, color=0xffffff, style=BRUSH_SOLID)
        ed.gap(GAP_ADD, num, id_bitmap)
</syntaxhighlight>

===Editor.dim===

 dim(id, index=0, index2=0, value=100)

Controls dim (shade, fade) ranges, which blend text font color with background color. Dim value is 0..255, 0 means "no effect", 255 means "text is transparent".

Possible values of "id":

* DIM_ADD: Adds new range.
** Param "index": index of first range line (0-base).
** Param "index2": index if last range line (value bigger than line count is allowed).
** Param "value": dim value.
* DIM_DELETE: Deletes one range. Param "index" is index of range (0-base).
* DIM_DELETE_ALL: Deletes all ranges.
* DIM_ENUM: Enumerates ranges. Gives list of 3-tuples (line_from, line_to, dim_value) or None.

===Editor.action===

 action(id, param1="", param2="", param3="")

Performs some action in editor. Possible values of "id":

* EDACTION_UPDATE: Repaints editor.

* EDACTION_SHOW_POS: Makes text position visible without caret moving. Gets True if params correct and scrolling occured, gets False if params correct and no scrolling occured, gets None if params not correct.
** "param1": Text position as 2-tuple (x, y).
** "param2": Indentation of text position from edges as 2-tuple (indent_horz, indent_vert). Values meaning is like for CudaText options "find_indent_horz", "find_indent_vert". 

* EDACTION_CODETREE_FILL: Fill some visual TreeView control (it can be standard code-tree control, or TreeView control in some form) with editor's code-tree information. Param "param1" must be TreeView handle (to use with tree_proc()). Gets True if lexer is set and information is read, otherwise False.

* EDACTION_LEXER_SCAN: Runs lexer parsing (if lexer is set) from line index, given by "param1". Waits until parsing finishes.

* EDACTION_EXPORT_HTML: Creates HTML file from editor's text with syntax highlighting. Gets bool: file is created. Param "param1" must be dict with the following keys:
** "file_name": str: Full path of file.
** "title": str: HTML page title.
** "font_name": str: Font name.
** "font_size": int: Font size, in HTML points.
** "with_numbers": bool: Show gutter with line numbers.
** "color_back": int: RGB color of page background.
** "color_numbers": int: RGB color of line numbers.

=TreeHelpers=

CudaText contains built-in support for TreeHelpers. They build code-tree for additional lexers. TreeHelpers must be plugins, which have special install.inf file.

Section [info]:
* key "subdir" must begin with "cuda_tree_"

Section(s) [treehelper1] ... [treehelper5]:
* key "lexers" is comma-separated lexers list
* key "method" is name of getter method in __init__.py

File __init__.py must contain getter method(s), referenced by install.inf. Getter has signature (with any name):

 def get_headers(filename, lines)

* param "lines" is list of str, editor contents in CudaText.
* param "filename" is full file path, it is to support included files or something.

Getter must return list of tuples: (pos, level, caption, icon).

* field "pos": tuple of int (x1, y1, x2, y2): range for tree node.
* field "level": 1-based level of node, node of level K+1 is nested into (nearest upper) node of level K.
* field "caption": caption of node.
* field "icon": 0-based index of icon from standard image-list, or -1 if icon not used.
** 0: folder
** 1: parts1
** 2: parts2
** 3: parts3
** 4: box
** 5: func
** 6: arrow1
** 7: arrow2

Getter can also return value not of "list" type, in this case CudaText will not update the code-tree.

See examples of TreeHelpers: for Markdown, for MediaWiki. They are add-ons in the CudaText AddonManager.

=Linters=

Linters are 2nd-level plugins for CudaLint plugin. CudaLint was ported from SublimeLinter 3, and its linters should be ported from SublimeLinter linters.
Here is example:

* Original linter: https://github.com/SublimeLinter/SublimeLinter-javac
* Ported linter: https://github.com/cudatext-addons/cuda_lint_javac

To see how to port, compare files "linter.py". Other files must be added like in other CudaLint linters.

=Tech info=

==Format of text for cmd_MouseClick==

Text is "X,Y" where X/Y are position of caret relative to top-caret (other carets removed when command runs). If Y is 0, X is addition to caret's x.
If Y not 0, Y is addition to caret's y, and X is absolute caret's x.

==Format of text for cmd_FinderAction==

Text is chr(1) separated items:

* item 0: finder action, one of:
** 'findfirst': find first
** 'findnext': find next
** 'findprev': find previous
** 'rep': replace next, and find next
** 'repstop': replace next, and don't find
** 'repall': replace all
** 'findcnt': count all
** 'findsel': find all, make selections
** 'findmark': find all, place markers
* item 1: text to find
* item 2: text to replace with
* item 3: several chars, each char is finder option:
** 'c': case sensitive
** 'r': regular expression
** 'w': whole words
** 'f': from caret
** 'o': confirm replaces
** 'a': wrapped search
** 's': search in selection
** 'T' followed by number: allowed syntax elements. Number is 0-based, it is index of "Allowed syntax elements" choice in the Find dialog.

==Format of serialized Undo/Redo==

Text is "\n"-separated lines, each line is Undo/Redo item. Each item is "\t"-separated elements:

* action, number 0..4. 0: change; 1: change EOL; 2: insert; 3: delete; 4: clear modified flag.
* line index, number from 0.
* end of line, number 0..3. 0: none; 1: CRLF; 2: LF; 3: CR.
* caret position(s). "x0,y0;x1,y1;x2,y2;" etc. 2*N numbers in total for N carets.
* soft mark flag, number 0/1 (boolean). Logic of soft/hard marks is described in wiki page [[ATSynEdit]].
* hard mark flag, number 0/1.
* line text, in UTF8. This text can have "\t", not a separator here.

=API of 3rd-party plugins=
==Options Editor==
Options Editor plugin (preinstalled in CudaText) has API which allows to call its dialog with custom options. Example shows dialog with 4 custom options, with custom title. Options which user changed in dialog will be saved to user.json or lexer-specific config.

<syntaxhighlight lang="Python">
import os
import json
import cuda_options_editor as op_ed

class Command:
    def config(self):
        info_file = os.path.dirname(__file__)+os.sep+'my plugin options.json'

        open(info_file, 'w').write(json.dumps([
        {   "opt": "my_opt_1",
            "cmt": ["Comment line 1",
                    "Comment line 2",
                    "Comment line 3"],
            "def": True,        # Default value
            "frm": "bool",      # Value type from
                                #   bool float int str - simple types
                                #   font - font name
                                #   font-e - font name or empty
                                #   hotk - hotkey
                                #   file - file path
                                #   strs  - list of str
                                #   int2s - dict int to str
                                #   str2s - dict str to str
            "chp": "MySection"  # Section (can be empty)
        },
        {   "opt": "my_opt_2",
            "cmt": ["Comment"],
            "def": "v1",
            "frm": "strs",
            "lst": ["v1", "v2"]
        },
        {   "opt": "my_opt_3",
            "cmt": ["Comment"],
            "def": 11,
            "frm": "int2s",
            "dct": [[11, "value for 11"], [22, "value for 22"]]
        },
        {   "opt": "my_opt_4",
            "cmt": ["Comment"],
            "def": "a",
            "frm": "int2s",
            "dct": [["a", "value for a"], ["b", "value for b"]]
        }
        ]))

        subset ='my plugin.' # Key for isolated storage on plugin settings
        title = 'My Options' # Dialog caption
        op_ed.OptEdD(path_keys_info=info_file, subset=subset).show(title)
</syntaxhighlight>

This will show:

[[File:cudatext_options_editor.png]]

==Project Manager==
Project Manager plugin (preinstalled in CudaText) gives API to read properties of currently opened project. It has global variable '''global_project_info''', which is dict with keys:

* "filename": Path of project file (*.cuda-proj), or empty string if project is not saved.
* "mainfile": Path of "main file" (which must be set by user from Project Manager context menu).
* "nodes": List of root project nodes, ie folder and file paths in the root level.
* "vars": List of variables defined in the Project Properties dialog. List of strings in the form "name=value".

Example:
<syntaxhighlight lang="Python">
     from cuda_project_man import global_project_info
     roots = global_project_info['nodes']
</syntaxhighlight>

Also global function '''project_variables()''' exists, which is handy wrapper around global_project_info. It returns dict with keys:

* "ProjDir": Folder of project file (*.cuda-proj).
* "ProjMainFile": Path of "main file".
* "ProjMainFileNameOnly": Only name of "main file", without path.
* "ProjMainFileNameNoExt": Name of "main file", without path and extension.
* Additional keys for project variables.

Its code currently is:

<syntaxhighlight lang="Python">
def project_variables():
    res = collections.OrderedDict()
    data = global_project_info
    res['ProjDir'] = os.path.dirname(data.get('filename', ''))

    fn = data.get('mainfile', '')
    res['ProjMainFile'] = fn
    res['ProjMainFileNameOnly'] = os.path.basename(fn)
    res['ProjMainFileNameNoExt'] = '.'.join(os.path.basename(fn).split('.')[0:-1])

    data = global_project_info.get('vars', [])
    for item in data:
        s1, s2 = item.split('=', maxsplit=1)
        res[s1] = s2
    return res
</syntaxhighlight>

=FAQ=

==How plugin can fill code-tree?==

* Handle events on_open, on_focus, on_change_slow (better don't use on_change, it slows down the app)
* Get handle of code-tree: h_tree = app_proc(PROC_GET_CODETREE, "")
* Fill tree via tree_proc(h_tree, ...)
** Disable standard tree filling via ed.set_prop(PROP_CODETREE, False)
** Clear tree via tree_proc(h_tree, TREE_ITEM_DELETE, id_item=0)
** On adding tree items, set range for them via tree_proc(h_tree, TREE_ITEM_SET_RANGE...)

==How plugin can show tooltips on mouse-over?==

* Create dialog for tooltip, via dlg_proc()

* Handle events on_open, on_focus, on_change_slow (better don't use on_change, it will slow down the app)
** Find text regions which need tooltip
** Delete old hotspots via ed.hotspot(HOTSPOT_DELETE_BY_TAG...)
** Add hotspots via ed.hotspots(HOTSPOT_ADD...)

* Handle event on_hotspot
** Find which text region is under cursor
** Fill dialog via dlg_proc()
** Set dialog prop "p" to the handle of editor, ed_self.h. Don't use ed.h, because it is virtual handle 0.
** Set dialog pos (props "x", "y") to editor-related pixel coords. It is complex. See example: plugin HTML Tooltips.
** Show dialog via dlg_proc(..., DLG_SHOW_NONMODAL)
* On exiting hotspot, hide dialog

==How to make formatter plugin?==

* Fork plugin CSS Format (or JS Format). It has most of code done. It has 3 commands done: Format, Config global, Config local.
* Replace/delete its CSS (JS) modules
* Change options filename, change loading of options
* Change contents of func do_format()

=History=

1.0.167
* add: timer_proc.

1.0.168
* add: app_proc: PROC_SAVE_SESSION/ PROC_LOAD_SESSION get bool (session was saved/loaded)
* add: dlg_custom: "label" has prop to right-align
* add: ed.get_prop/set_prop: value can be int/bool too

1.0.169
* add: ed.insert does append, if y too big
* add: ed.delete can use too big y2

1.0.170
* add: app_proc: PROC_SET_CLIP_ALT

1.0.171
* add: app_proc: PROC_SIDEPANEL_ADD takes additional value icon_filename
* deprecated: app_log: LOG_PANEL_ADD
* deprecated: app_log: LOG_PANEL_DELETE
* deprecated: app_log: LOG_PANEL_FOCUS

1.0.172
* add: menu_proc()
* deprecated: app_proc actions: PROC_MENU_*
* change: PROP_ENC now uses short names, see [[CudaText#Encodings]]

1.0.173
* add: dlg_commands()
* add: toolbar_proc()
* deprecated: app_proc actions: PROC_TOOLBAR_*

1.0.174
* add: dlg_custom: "name=" (not required)
* add: dlg_custom: "font="
* add: dlg_custom: "type=filter_listbox", "type=filter_listview". To setup these filter controls, you must set "name=" for filter and its listbox/listview
* add: app_proc: PROC_ENUM_FONTS

1.0.175
* add: dlg_proc()
* add: dlg_custom: added props x= y= w= h= vis= color= font_name= font_size= font_color=
* add: timer_proc: can also use callbacks "module=nnn;cmd=nnn;" and "module=nnn;func=nnn;"
* add: timer_proc: added param "tag"
* add: menu_proc: actions MENU_CREATE, MENU_SHOW

1.0.176
* reworked dlg_proc, many form props+events added
* add: dlg_proc/dlg_custom: control type "treeview"
* add: dlg_proc/dlg_custom: control type "listbox_ex"
* add: dlg_proc/dlg_custom: control type "trackbar"
* add: dlg_proc/dlg_custom: control type "progressbar"
* add: dlg_proc/dlg_custom: control type "progressbar_ex"
* add: dlg_proc/dlg_custom: control type "bevel"
* add: file_open: added param "args"
* add: toolbar_proc: TOOLBAR_GET_CHECKED, TOOLBAR_SET_CHECKED
* delete: event on_dlg
* delete: dlg_proc/dlg_custom: prop "font" (use font_name, font_size, font_color)
* delete: deprecated APIs LOG_PANEL_ADD LOG_PANEL_DELETE LOG_PANEL_FOCUS
* delete: deprecated APIs PROC_TOOLBAR_*

1.0.177
* add: ed.replace
* add: ed.replace_lines
* add: dlg_custom: parameter "get_dict" to get new dict result (not tuple)
* add: dlg_proc: action DLG_SCALE
* add: app_proc: action PROC_GET_SYSTEM_PPI

1.0.178
* add: dlg_proc: control props for anchors/spacing: "a_*", "sp_*"
* add: dlg_proc: param "name" to specify controls by name
* add: dlg_proc: form prop "color"
* add: dlg_proc: form prop "autosize"
* add: dlg_proc: actions DLG_DOCK, DLG_UNDOCK
* add: dlg_custom/dlg_proc: control type "paintbox"

1.0.179
* add: dlg_proc/timer_proc/menu_proc: callbacks can be "callable", ie function names
* add: dlg_proc/timer_proc: callbacks can be with "info=...;" at end
* add: menu_proc: can use new-style callbacks like in dlg_proc
* deprecated: menu_proc old-style callbacks "module,method[,param]"

1.0.180
* add: app_proc: PROC_SHOW_SIDEBAR_GET, PROC_SHOW_SIDEBAR_SET
* add: app_proc: can pass not only string value
* add: ed.get_prop: PROP_COORDS
* add: dlg_proc/dlg_custom: type "panel", type "group"
* add: dlg_proc: control prop "p" (parent)

1.0.181
* add: dlg_proc/dlg_custom: type "pages"
* add: dlg_proc: control "paintbox" has sub-event "on_click" with info="x,y"

1.0.182
* add: dlg_proc: type "toolbar"
* add: app_proc: PROC_PROGRESSBAR
* add: app_proc: PROC_SPLITTER_GET, PROC_SPLITTER_SET
* deprecated: app_proc: PROC_GET_SPLIT, PROC_SET_SPLIT
* add: app_log: LOG_CONSOLE_GET_COMBO_LINES
* add: app_log: LOG_CONSOLE_GET_MEMO_LINES
* add: app_log: LOG_GET_LINES_LIST
* deprecated: app_log: LOG_CONSOLE_GET, LOG_CONSOLE_GET_LOG, LOG_GET_LINES

1.0.183
* big changes in dlg_proc:
** deleted: parameter 'id_event'
** deleted: props 'callback', 'events'
** form events is not called for controls (forms have own events, controls have own events)
** add: events for forms: 'on_resize', 'on_close', 'on_close_query', 'on_key_down', 'on_key_up'
** add: events for controls: 'on_change', 'on_click', 'on_click_dbl', 'on_select', 'on_menu'
** add: events for 'treeview' control: 'on_fold', 'on_unfold'

1.0.184
* deprecated: app_proc: PROC_SIDEPANEL_ADD, PROC_BOTTOMPANEL_ADD
* deprecated: on_panel event
* add: app_proc: PROC_SIDEPANEL_ADD_DIALOG, PROC_BOTTOMPANEL_ADD_DIALOG
* add: tree_proc: TREE_ITEM_FOLD_LEVEL
* add: tree_proc: TREE_THEME
* add: listbox_proc: LISTBOX_THEME
* add: toolbar_proc: TOOLBAR_THEME
* add: toolbar_proc: used new callback form
* add: menu_proc: MENU_SHOW with command="" to show at cursor
* add: menu_proc: added param "hotkey" for MENU_ADD, "hotkey" returned from MENU_ENUM
* deleted deprecated: PROC_GET_SPLIT, PROC_SET_SPLIT
* deleted deprecated: LOG_GET_LINES
* deleted deprecated: LOG_CONSOLE_GET, LOG_CONSOLE_GET_LOG

1.0.185 (app 1.11.0)
* add: menu_proc: for MENU_ADD added param "tag"
* add: menu_proc: MENU_SHOW can use 2-tuple (x,y)
* add: menu_proc: MENU_ENUM gives additional dict key "command"
* deprecated: menu_proc command values: "recents", "enc", "langs", "lexers", "plugins", "themes-ui", "themes-syntax"

1.0.186 (app 1.12.0)
* add: tree_proc: TREE_ICON_GET_SIZES, TREE_ICON_SET_SIZES
* deleted deprecated: app_proc: PROC_MENU_* actions
* deleted deprecated: app_proc: PROC_SIDEPANEL_ADD, PROC_BOTTOMPANEL_ADD

1.0.187 (app 1.12.2)
* add: lexer_proc: LEXER_GET_PROP
* deprecated: lexer_proc: LEXER_GET_EXT, LEXER_GET_ENABLED, LEXER_GET_COMMENT, LEXER_GET_COMMENT_STREAM, LEXER_GET_COMMENT_LINED, LEXER_GET_LINKS, LEXER_GET_STYLES, LEXER_GET_STYLES_COMMENTS, LEXER_GET_STYLES_STRINGS
* deleted: lexer_proc: actions didnt work, lexer files were not saved: LEXER_SET_*, LEXER_DELETE, LEXER_IMPORT
* add: dlg_proc: control "listview" on_select gets "data" param with 2-tuple

1.0.188 (app 1.13.0)
* add: imagelist_proc()
* add: tree_proc: TREE_GET_IMAGELIST
* add: toolbar_proc: TOOLBAR_GET_IMAGELIST
* add: lexer_proc: LEXER_GET_LEXERS
* deprecated: tree_proc: TREE_ICON_ADD, TREE_ICON_DELETE, TREE_ICON_GET_SIZES, TREE_ICON_SET_SIZES
* deprecated: toolbar_proc: TOOLBAR_GET_ICON_SIZES, TOOLBAR_SET_ICON_SIZES, TOOLBAR_ADD_ICON
* deprecated: lexer_proc: LEXER_GET_LIST

1.0.189 (app 1.13.1)
* add: tree_proc: TREE_ITEM_SHOW

1.0.190 (app 1.14.0)
* add: app_proc: PROC_GET_TAB_IMAGELIST
* add: ed.get_prop/ed.set_prop: PROP_TAB_ICON
* add: imagelist_proc: IMAGELIST_PAINT

1.0.191 (app 1.14.2)
* add: dlg_proc: form property "border"
* add: dlg_proc: control type "button_ex"
* add: button_proc() to work with "button_ex"

1.0.192 (app 1.14.8)
* add: dlg_proc: control type "splitter"
* add: dlg_proc: control prop "align"
* add: dlg_proc: control "listbox_ex" has event "on_draw_item"
* add: listbox_proc: actions LISTBOX_GET_ITEM_H, LISTBOX_SET_ITEM_H
* add: listbox_proc: actions LISTBOX_GET_DRAWN, LISTBOX_SET_DRAWN
* add: event on_paste
* deleted deprecated: event on_panel
* deleted deprecated: menu_proc spec strings: "recents", "enc", "langs", "lexers", "plugins", "themes-ui", "themes-syntax"

1.0.193 (app 1.15.0)
* add: image_proc()
* deleted: canvas_proc actions: CANVAS_IMAGE, CANVAS_IMAGE_SIZED (use image_proc instead)
* add: dlg_menu can have argument of type list/tuple
* add: dlg_menu can have argument "caption"

1.0.194 (app 1.15.4)
* add: app_proc: PROC_SIDEPANEL_ACTIVATE has 2nd param
* add: menu_proc: MENU_GET_PROP
* add: menu_proc: MENU_SET_CAPTION
* add: menu_proc: MENU_SET_VISIBLE
* add: menu_proc: MENU_SET_ENABLED
* add: menu_proc: MENU_SET_CHECKED
* add: menu_proc: MENU_SET_RADIOITEM
* add: menu_proc: MENU_SET_HOTKEY
* add: tree_proc: TREE_ITEM_GET_PROPS
* deprecated: tree_proc: TREE_ITEM_GET_PROP, TREE_ITEM_GET_PARENT

1.0.195 (app 1.15.5)
* add: dlg_proc: control prop "border"
* add: dlg_proc: control "linklabel" uses "on_click" (after opening URL if it's valid)

1.0.196 (app 1.16.2)
* add: ed.dim()

1.0.197 (app 1.17.2)
* add: dlg_proc: type "editor"
* add: object ed_goto
* add: objects ed_con_log, ed_con_in
* add: events: on_goto_enter, on_goto_change, on_goto_caret, on_goto_key, on_goto_key_up
* add: ed.get_prop/set_prop: PROP_ONE_LINE
* add: ed.get_prop/set_prop: PROP_LINE_NUMBERS

1.0.198 (app 1.18.0)
* add: constants WRAP_nnn
* add: ed.set_prop works for PROP_LINE_STATE

1.0.199 (app 1.19.2)
* add: toolbar_proc: TOOLBAR_GET_VERTICAL, TOOLBAR_SET_VERTICAL
* add: toolbar_proc: TOOLBAR_GET_WRAP, TOOLBAR_SET_WRAP
* deleted deprecated: TOOLBAR_GET_ICON_SIZES, TOOLBAR_SET_ICON_SIZES, TOOLBAR_ADD_ICON
* deleted deprecated: TREE_ITEM_GET_PROP, TREE_ITEM_GET_PARENT
* deleted deprecated: TREE_ICON_ADD, TREE_ICON_DELETE, TREE_ICON_GET_SIZES, TREE_ICON_SET_SIZES
* deleted deprecated: LEXER_GET_LIST, LEXER_GET_EXT, LEXER_GET_ENABLED, LEXER_GET_COMMENT, LEXER_GET_COMMENT_STREAM, LEXER_GET_COMMENT_LINED, LEXER_GET_LINKS, LEXER_GET_STYLES, LEXER_GET_STYLES_COMMENTS, LEXER_GET_STYLES_STRINGS

1.0.200 (app 1.20.2)
* add: event on_insert

1.0.201 (app 1.21.0)
* add: several commands in cudatext_cmd.py: simple word jump, goto abs line begin/end

1.0.202 (app 1.23.0)
* add: file_open: can open preview-tab
* add: file_open: can open file ignoring history
* change: renamed file_open param "args" to "options"

1.0.203 (app 1.23.4)
* add: event on_scroll
* add: event on_group
* add: file_open: options can have "/noevent"

1.0.204 (app 1.23.5)
* add: ed.get_wrapinfo()
* add: ed.get_prop/ed.set_prop: PROP_SCROLL_VERT, PROP_SCROLL_HORZ
* add: ed.export_html()
* deleted: ed.set_prop: PROP_EXPORT_HTML

1.0.205 (app 1.24.1)
* add: dlg_proc: ctl "edit" supports "on_change" (if "act":True)

1.0.206 (app 1.24.2)
* add: dlg_proc: added ctl property "focused"
* add: dlg_proc: added form events "on_act", "on_deact"

1.0.207 (app 1.25.1)
* add: app_proc: PROC_GET_COMMANDS

1.0.208 (app 1.26.2)
* add: lexer_proc supports lite lexers too (their names have " ^" suffix)

1.0.208 (app 1.27.2)
* add: menu_proc: added MENU_SET_IMAGELIST, MENU_SET_IMAGEINDEX
* add: file_open: for zip files, gets True if zip installation completed

1.0.210 (app 1.29.0)
* add: file_open: for binary viewer, pass options='/binary'
* add: ed.get_prop/set_prop: PROP_KIND, PROP_V_MODE, PROP_V_POS, PROP_V_SEL_START, PROP_V_SEL_LEN

1.0.211 (app 1.32.0)
* add: statusbar_proc()
* add: dlg_proc: added type "statusbar"
* add: toolbar_proc: TOOLBAR_UPDATE

1.0.212 (app 1.32.2)
* add: toolbar_proc: TOOLBAR_GET_COUNT
* add: toolbar_proc: TOOLBAR_GET_BUTTON_HANDLE
* add: button_proc: BTN_GET_TEXT, BTN_SET_TEXT
* add: button_proc: BTN_GET_ENABLED, BTN_SET_ENABLED
* add: button_proc: BTN_GET_VISIBLE, BTN_SET_VISIBLE
* add: button_proc: BTN_GET_HINT, BTN_SET_HINT
* add: button_proc: BTN_GET_DATA1, BTN_SET_DATA1, BTN_GET_DATA2, BTN_SET_DATA2
* change: toolbar_proc: TOOLBAR_ENUM gets int value of "kind", before it was str
* deprecated: TOOLBAR_GET_CHECKED, TOOLBAR_SET_CHECKED - now use TOOLBAR_GET_BUTTON_HANDLE + button_proc()
* deprecated: PROC_GET_COMMAND, PROC_GET_COMMAND_INITIAL, PROC_GET_COMMAND_PLUGIN - now use PROC_GET_COMMANDS instead

1.0.213 (app 1.32.3)
* add: button_proc: BTN_GET_MENU, BTN_SET_MENU
* add: button_proc: BTN_GET_ARROW, BTN_SET_ARROW
* add: button_proc: BTN_GET_FOCUSABLE, BTN_SET_FOCUSABLE
* add: button_proc: BTN_GET_FLAT, BTN_SET_FLAT
* add: toolbar_proc: TOOLBAR_ADD_ITEM, TOOLBAR_ADD_MENU
* deprecated: toolbar_proc: TOOLBAR_ADD_BUTTON - now use TOOLBAR_ADD_ITEM/TOOLBAR_ADD_MENU + button_proc()
* deprecated: toolbar_proc: TOOLBAR_SET_BUTTON - now use TOOLBAR_GET_BUTTON_HANDLE + button_proc()
* deprecated: toolbar_proc: TOOLBAR_ENUM - now use TOOLBAR_GET_COUNT + TOOLBAR_GET_BUTTON_HANDLE + button_proc()

1.0.214 (app 1.32.4)
* add: button_proc supports callable param "value"

1.0.215 (app 1.34.1)
* add: dlg_proc: DLG_CTL_PROP_GET gets key "items" for controls "listview", "checklistview", "listbox", "checklistbox"

1.0.216 (app 1.34.2)
* add: statusbar_proc: STATUSBAR_GET_CELL_AUTOSIZE, STATUSBAR_SET_CELL_AUTOSIZE
* add: statusbar_proc: STATUSBAR_GET_CELL_AUTOSTRETCH, STATUSBAR_SET_CELL_AUTOSTRETCH
* add: statusbar_proc: 10 actions to get/set colors, STATUSBAR_GET/SET_COLOR_*
* deleted: STATUSBAR_GET_COLOR_BORDER, STATUSBAR_SET_COLOR_BORDER
* deleted: STATUSBAR_AUTOSIZE_CELL - now use STATUSBAR_SET_CELL_AUTOSTRETCH

1.0.217 (app 1.34.4)
* add: button_proc: const BTNKIND_TEXT_CHOICE
* add: button_proc: BTN_GET_WIDTH, BTN_SET_WIDTH
* add: button_proc: BTN_GET_ITEMS, BTN_SET_ITEMS
* add: button_proc: BTN_GET_ITEMINDEX, BTN_SET_ITEMINDEX
* add: button_proc: BTN_GET_ARROW_ALIGN, BTN_SET_ARROW_ALIGN
* add: button_proc: BTN_UPDATE

1.0.218 (app 1.38.0)
* add: Editor.hotspots()
* add: event on_hotspot
* add: app_proc: PROC_GET_MOUSE_POS
* add: dlg_proc: DLG_PROP_SET supports prop "p" (parent of form)
* add: Editor.convert: CONVERT_SCREEN_TO_LOCAL, CONVERT_LOCAL_TO_SCREEN
* add: Editor.convert: CONVERT_PIXELS_TO_CARET, CONVERT_CARET_TO_PIXELS
* add: Editor.markers: MARKERS_DELETE_BY_TAG
* add: Editor.get_prop: PROP_CELL_SIZE

1.0.219 (app 1.38.1)
* add: app_proc: PROC_THEME_UI_DATA_GET
* add: app_proc: PROC_THEME_SYNTAX_DATA_GET

1.0.220 (app 1.38.2)
* add: on_state event aslo called with new constants APPSTATE_nnnn

1.0.221 (app 1.38.3)
* add: Editor.get_prop/set_prop: PROP_INDENT_SIZE, PROP_INDENT_KEEP_ALIGN, PROP_INDENT_AUTO, PROP_INDENT_KIND

1.0.222 (app 1.38.5)
* add: dlg_proc: form events "on_mouse_enter", "on_mouse_exit"
* add: dlg_proc: form events "on_show", "on_hide"
* add: dlg_proc: control events "on_mouse_enter", "on_mouse_exit", "on_mouse_down", "on_mouse_up"

1.0.223 (app 1.39.1)
* add: install.inf supports param [info] os=, value is comma separated strings: win, linux, macos
* add: menu_proc: support for spec menu id "_oplugins"

1.0.224 (app 1.39.5)
* add: dlg_proc: control prop "ex"
* deprecated: dlg_proc/dlg_custom prop "props" - now use "ex0"..."ex9"
* deprecated: BOOKMARK_CLEAR_HINTS

1.0.225 (app 1.40.0)
* add: app_proc: PROC_SEND_MESSAGE

1.0.226 (app 1.40.1)
* add: app_proc: PROC_GET_CODETREE
* add: Editor.get_prop/set_prop: PROP_CODETREE
* add: tree_proc: TREE_ITEM_GET_RANGE, TREE_ITEM_SET_RANGE
* deprecated: tree_proc: TREE_ITEM_GET_SYNTAX_RANGE
* change: changed Code-Tree button caption from "Tree" to "Code tree"

1.0.227 (app 1.40.2)
* add: file_open: added options "/passive", "/nonear"

1.0.228 (app 1.40.7)
* add: event on_tab_change

1.0.229 (app 1.43.0)
* add: plugins can force show sidebar button, even if they don't run on start. New install.inf sections [sidebar1] .. [sidebar3]. Examples: ProjectManager, TabsList.

1.0.230 (app 1.44.0)
* add: dlg_proc: control "listview"/"checklistview" has event "on_click_header"
* add: install.inf: allow os= values with bitness: win32, win64, linux32, linux64, freebsd32, freebsd64
* deleted deprecated: PROC_GET_COMMAND
* deleted deprecated: PROC_GET_COMMAND_INITIAL
* deleted deprecated: PROC_GET_COMMAND_PLUGIN

1.0.231 (app 1.45.5)
* add: dlg_proc: control "listview" has prop "columns"
* removed: on_group; on_state(..., APPSTATE_GROUPS) called instead

1.0.232 (app 1.46.2)
* add: dlg_proc: control "radiogroup" has prop "columns"
* add: dlg_proc: control "radiogroup" has prop "ex0"
* add: Editor.get_prop/set_prop: PROP_GUTTER_ALL, PROP_GUTTER_STATES

1.0.233 (app 1.47.0)
* add: dlg_menu: option MENU_NO_FUZZY
* add: dlg_menu: option MENU_NO_FULLFILTER

1.0.233 (app 1.47.1)
* add: app_proc: PROC_GET_GUI_HEIGHT supports name "scrollbar"

1.0.234 (app 1.47.5)
* add: event on_exit
* add: ed.get_prop/set_prop: PROP_UNPRINTED_SPACES_TRAILING
* add: ed.get_prop/set_prop: PROP_LAST_LINE_ON_TOP
* add: ed.get_prop/set_prop: PROP_HILITE_CUR_COL
* add: ed.get_prop/set_prop: PROP_HILITE_CUR_LINE
* add: ed.get_prop/set_prop: PROP_HILITE_CUR_LINE_MINIMAL
* add: ed.get_prop/set_prop: PROP_HILITE_CUR_LINE_IF_FOCUS
* add: ed.get_prop/set_prop: PROP_MODERN_SCROLLBAR

1.0.235 (app 1.48.2)
* add: support for "lazy events"
* add: event on_console_print
* add: lexer_proc: LEXER_REREAD_LIB

1.0.236 (app 1.48.3)
* add: dlg_proc: controls have props "w_min/w_max/h_min/h_max", like forms
* fix: bug in dlg_proc/dlg_custom: controls with changed parent become not findable by name/index (and count of controls becomes smaller)

1.0.237 (app 1.49.1)
* add: statusbar_proc: STATUSBAR_GET_CELL_HINT, STATUSBAR_SET_CELL_HINT

1.0.238 (app 1.49.5)
* add: dlg_proc/dlg_custom: controls have prop "font_style"
* add: file_open: options "/view-text", "/view-binary", "/view-hex", "/view-unicode"
* change: file_open: deleted option "/binary"

1.0.239 (app 1.51.2)
* add: event on_mouse_stop

1.0.240 (app 1.52.1)
* add: ed.bookmark: BOOKMARK_SET can specify "delete bookmark on deleting line"
* deleted deprecated: BOOKMARK_CLEAR_HINTS
* deleted deprecated: TREE_ITEM_GET_SYNTAX_RANGE

1.0.242 (app 1.53.6)
* add/change: dlg_proc: form property "border" is now enum, with DBORDER_nnn values
* deprecated: dlg_proc: form property "resize"
* deleted deprecated: TOOLBAR_SET_BUTTON, TOOLBAR_ADD_BUTTON, TOOLBAR_ENUM, TOOLBAR_GET_CHECKED, TOOLBAR_SET_CHECKED

1.0.243 (app 1.55.0)
* add: event on_click_gutter
* deleted: events on_goto_enter, on_goto_change, on_goto_caret, on_goto_key, on_goto_key_up
* add: additional group indexes 6..8 for floating groups
* add: app_proc: PROC_SHOW_FLOATGROUP1_GET, PROC_SHOW_FLOATGROUP1_SET
* add: app_proc: PROC_SHOW_FLOATGROUP2_GET, PROC_SHOW_FLOATGROUP2_SET
* add: app_proc: PROC_SHOW_FLOATGROUP3_GET, PROC_SHOW_FLOATGROUP3_SET
* add: app_proc: PROC_FLOAT_SIDE_GET, PROC_FLOAT_SIDE_SET
* add: app_proc: PROC_FLOAT_BOTTOM_GET, PROC_FLOAT_BOTTOM_SET

1.0.244 (app 1.55.1)
* deleted: object ed_goto

1.0.245 (app 1.55.3)
* add: Editor.get_prop/set_prop: PROP_CARET_STOP_UNFOCUSED
* add: addon can require other addon(s) via install.inf: [info] req=cuda_aa,cuda_bb

1.0.246 (app 1.56.1)
* add: dlg_proc: controls have prop "autosize"
* add: dlg_proc: added events for control "editor": on_change, on_caret, on_scroll, on_key_down, on_key_up, on_click_gutter, on_click_gap, on_paste
* add: addon can require lexer(s) via install.inf: [info] reqlexer=Name1,Name2

1.0.247 (app 1.56.3)
* add: event on_close_pre
* add: ed.get_prop/set_prop: PROP_FOLD_ALWAYS
* add: ed.get_prop/set_prop: PROP_FOLD_ICONS
* add: ed.get_prop/set_prop: PROP_FOLD_TOOLTIP_SHOW

1.0.248 (app 1.56.6)
* add: app_proc: PROC_GET_FINDER_PROP
* add: app_proc: PROC_SET_FINDER_PROP
* deprecated: app_proc: PROC_GET_FIND_OPTIONS
* deprecated: app_proc: PROC_SET_FIND_OPTIONS
* deprecated: app_proc: PROC_GET_FIND_STRINGS

1.0.249 (app 1.57.5)
* add: dlg_proc: control "pages" supports prop "val"
* add: dlg_proc: control event "on_menu" can return False to disable default menu
* add: Editor.get_token: TOKEN_LIST, TOKEN_LIST_SUB
* add: Editor.get_token: index params are optional now
* deprecated: Editor.get_token: TOKEN_AT_POS, TOKEN_INDEX (now use TOKEN_LIST, TOKEN_LIST_SUB)

1.0.250 (app 1.57.7)
* add: event "on_open_none"
* add: dlg_proc: event "on_menu" has filled param "data" like in "on_mouse_down"

1.0.251 (app 1.57.8)
* add: Editor.get_prop: PROP_ACTIVATION_TIME

1.0.252 (app 1.58.1)
* add: app_log: added optional param "panel"
* add: Editor.bookmark: added 3 optional params: "auto_del", "show", "tag"
* add: Editor.bookmark: BOOKMARK_GET_ALL
* add: Editor.bookmark: BOOKMARK_GET_PROP
* add: Editor.bookmark: BOOKMARK_DELETE_BY_TAG
* change: Editor.bookmark: BOOKMARK_SET sets flag "delete on deleting line" from new param "auto_del" now (before: from "ncolor=1")
* change: on_change/on_change_slow now isn't called on file opening
* deprecated: app_log: LOG_SET_PANEL (now use parameter "panel")
* deprecated: Editor.bookmark: BOOKMARK_GET (now use BOOKMARK_GET_PROP)

1.0.253 (app 1.59.0)
* add: Editor.attr: added optional param "show_on_map"
* add: Editor.get_prop(PROP_ACTIVATION_TIME) is 0 for not yet focused tabs
* add: app_proc: PROC_BOTTOMPANEL_ACTIVATE now handles tuple like PROC_SIDEPANEL_ACTIVATE

1.0.254 (app 1.60.1)
* add: event on_tab_switch

1.0.255 (app 1.60.5)
* add: module cudax_nodejs
* add: menu_proc: support menu id "tab"
* add: menu_proc: MENU_REMOVE
* add: Editor.folding: FOLDING_FOLD_ALL
* add: Editor.folding: FOLDING_FOLD_LEVEL
* add: Editor.folding: FOLDING_UNFOLD_ALL
* add: Editor.folding: FOLDING_UNFOLD_LINE

1.0.256 (app 1.60.7)
* add: Editor.decor()

1.0.257 (app 1.62.0)
* deleted deprecated: TOKEN_AT_POS, TOKEN_INDEX (now use TOKEN_LIST, TOKEN_LIST_SUB)
* deleted deprecated: BOOKMARK_GET (now use BOOKMARK_GET_PROP)
* deleted deprecated: LOG_SET_PANEL (now use parameter "panel")

1.0.258 (app 1.62.5)
* deleted deprecated: PROC_GET_FIND_OPTIONS, PROC_GET_FIND_STRINGS (now use PROC_GET_FINDER_PROP)
* deleted deprecated: PROC_SET_FIND_OPTIONS (now use PROC_SET_FINDER_PROP)

1.0.259 (app 1.63.5)
* add: Editor.get_prop/set_prop: PROP_SAVE_HISTORY
* add: Editor.get_prop/set_prop: PROP_PREVIEW

1.0.260 (app 1.63.6)
* deleted event "on_console"
* deleted event "on_console_print"

1.0.261 (app 1.64.2)
* add: event on_goto_enter
* add: Editor.get_prop/set_prop: PROP_CARET_VIEW, PROP_CARET_VIEW_OVR, PROP_CARET_VIEW_RO
* deleted: Editor.get_prop/set_prop: PROP_CARET_SHAPE, PROP_CARET_SHAPE_OVR, PROP_CARET_SHAPE_RO

1.0.262 (app 1.64.4)
* add: ini_proc()
* add: app_proc: PROC_GET_KEYSTATE gets also state of pressed mouse buttons

1.0.263 (app 1.65.6)
* add: event on_lexer_parsed

1.0.264 (app 1.66.7)
* add: app_proc: PROC_SHOW_TREEFILTER_GET, _SET
* add: Editor.get_prop/set_prop: PROP_UNDO_GROUPED
* add: Editor.get_prop/set_prop: PROP_UNDO_LIMIT

1.0.265 (app 1.66.9)
* add: Editor.get_prop/set_prop: PROP_UNDO_DATA
* add: Editor.get_prop/set_prop: PROP_REDO_DATA
* add: Editor.folding: FOLDING_GET_LIST_FILTERED

1.0.266 (app 1.67.0)
* add: dlg_commands: add COMMANDS_CENTERED
* add: dlg_commands: add "title" param

1.0.267 (app 1.70.3)
* add: on_state: add APPSTATE_CONFIG_REREAD
* add: on_state: add APPSTATE_SESSION_LOAD

1.0.268 (app 1.71.5)
* add: event on_save_naming

1.0.269 (app 1.71.6)
* add: Editor.gap: allowed gap before the first line (line index = -1)
* add: file_open: options "/nontext-view-text", "/nontext-view-binary", "/nontext-view-hex", "/nontext-view-unicode", "/nontext-cancel"
* add: file_open: options "/nozip", "/nopictures"

1.0.270 (app 1.72.1)
* add: app_proc: PROC_WINDOW_TOPMOST_GET, PROC_WINDOW_TOPMOST_SET

1.0.271 (app 1.73.1)
* add: Editor.bookmark: added actions BOOKMARK2_*

1.0.272 (app 1.74.0)
* add: file_open: can open 2 files in a single tab
* add: Editor.get_prop/set_prop: PROP_EDITORS_LINKED
* add: Editor.get_prop/set_prop: PROP_SPLIT
* add: Editor.get_prop: PROP_HANDLE_SELF, PROP_HANDLE_PRIMARY, PROP_HANDLE_SECONDARY
* add: Editor.get_prop: PROP_RECT_CLIENT, PROP_RECT_TEXT
* change: deleted object "ed_bro"
* deprecated: file_save(); use ed.save() instead
* deprecated: Editor.get_split, Editor.set_split; use PROP_SPLIT instead

1.0.273 (app 1.74.1)
* add: Editor.gap: added params "size", "color"
* add: app_proc: PROC_SIDEPANEL_GET
* add: app_proc: PROC_BOTTOMPANEL_GET

1.0.274 (app 1.74.7)
* deleted deprecated: file_save()
* deleted deprecated: Editor.get_split, Editor.set_split
* add: Editor.gap: no limit for gap height

1.0.275 (app 1.76.0)
* add: Editor.get_text_line has optional param "max_len"
* add: dlg_menu: added MENU_CENTERED

1.0.276 (app 1.76.6)
* add: dlg_proc: form has property "p" (handle of parent form)

1.0.277 (app 1.77.2)
* change: dlg_proc: "memo" value must encode tab as chr(3) now (was chr(2))
* add: get_prop: PROP_CODETREE_MODIFIED_VERSION

1.0.278 (app 1.77.4)
* add: Editor.get_prop/set_prop: PROP_SAVING_FORCE_FINAL_EOL
* add: Editor.get_prop/set_prop: PROP_SAVING_TRIM_SPACES
* add: Editor.get_prop/set_prop: PROP_SAVING_TRIM_FINAL_EMPTY_LINES

1.0.279 (app 1.77.6)
* add: app_proc: PROC_CONFIG_READ
* add: app_proc: PROC_CONFIG_NEWDOC_EOL_GET
* add: app_proc: PROC_CONFIG_NEWDOC_EOL_SET
* add: app_proc: PROC_CONFIG_NEWDOC_ENC_GET
* add: app_proc: PROC_CONFIG_NEWDOC_ENC_SET

1.0.280 (app 1.77.6)
* add: Editor.get_prop/set_prop: PROP_NEWLINE
* deprecated: PROP_EOL

1.0.281 (app 1.78.5)
* add: Editor.get_prop/set_prop: PROP_SCROLL_VERT_SMOOTH, PROP_SCROLL_HORZ_SMOOTH
* add: Editor.get_prop: PROP_SCROLL_VERT_INFO, PROP_SCROLL_HORZ_INFO
* add: Editor.get_wrapinfo: dict result has additional "initial" field
* deprecated: PROP_COLUMN_LEFT; use PROP_SCROLL_HORZ instead

1.0.282 (app 1.78.6)
* add: Editor.get_prop: PROP_LINE_STATES
* add: Editor.get_prop: PROP_LINE_STATES_UPDATED
* change: PROP_TAG is now stored per Editor object, so primary and secondary editors (in the same tab) have different PROP_TAG values
* add: TreeHelper getter can return not "list" type, to not refresh code tree

1.0.283 (app 1.78.7)
* add: Editor.get_prop/set_prop: PROP_ZEBRA

1.0.284 (app 1.79.0)
* add: msg_box_ex()
* add: Editor.get_prop/set_prop: COLOR_ID_BorderFocused, COLOR_ID_MinimapTooltipBg, COLOR_ID_MinimapTooltipBorder, COLOR_ID_BlockStapleActive
* add: app_proc: ids SPLITTER_G4, SPLITTER_G5

1.0.285 (app 1.79.1)
* add: Editor.gap: GAP_GET_ALL
* deprecated: GAP_GET_LIST

1.0.286 (app 1.79.2)
* add: Editor.get_prop: PROP_HANDLE_PARENT
* add: const COLOR_DEFAULT

1.0.287 (app 1.79.3)
* add: Editor.set_caret: param "options"
* add: Editor.set_caret: CARET_DELETE_INDEX
* add: Editor.get_filename: param "options"
* add: toolbar_proc: TOOLBAR_GET_BUTTON_HANDLES

1.0.288 (app 1.81.0)
* add: for BOOKMARK_SETUP it's allowed to use COLOR_DEFAULT
* change: removed menu id "_langs"
* change: removed menu id "_themes-ui"
* change: removed menu id "_themes-syntax"

1.0.289 (app 1.81.2)
* add: Editor.action()
* deprecated: Editor.lexer_scan()
* deprecated: Editor.export_html()

1.0.290 (app 1.81.3)
* add: listbox_proc: LISTBOX_GET_COLUMN_SEP, LISTBOX_SET_COLUMN_SEP
* add: listbox_proc: LISTBOX_GET_COLUMNS, LISTBOX_SET_COLUMNS
* removed: LISTBOX_THEME
* removed: event "on_tab_switch"

1.0.291 (app 1.83.0)
* add: emmet()
* add: app_proc: PROC_GET_FINDER_PROP dict has keys for option "Allowed syntax elements"

1.0.292 (app 1.83.2)
* add: Editor.action: EDACTION_UPDATE
* add: Editor.action: EDACTION_SHOW_POS

1.0.293 (app 1.84.2)
* removed deprecated: Editor.lexer_scan
* removed deprecated: Editor.export_html
* removed deprecated: PROP_COLUMN_LEFT
* removed deprecated: GAP_GET_LIST
* removed deprecated: PROP_EOL
* add: install.inf support for data with empty "subdir"
* add: install.inf support for "type=cudatext-package"

1.0.294 (app 1.84.5)
* add: timer_proc: behaviour when TIMER_START* restarts existing timer: now action updates old timer's tag to new value

1.0.295 (app 1.84.6)
* change: msg_status_alt now shows floating tooltip on the top (before: was statusbar on the bottom)

1.0.296 (app 1.85.1)
* add: dlg_proc: control property "texthint"

1.0.297 (app 1.85.1)
* add: dlg_dir: param "caption"
* add: dlg_file: param "caption"

1.0.298 (app 1.85.2)
* add: dlg_proc: control events "on_focus_enter", "on_focus_exit"

[[Category:CudaText]]
